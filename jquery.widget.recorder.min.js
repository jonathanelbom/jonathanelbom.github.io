(function (root, factory) { root.undefined = factory(); }(this, function () {/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

define(
    'worker-functions',[],
    function () {
		var workers = {};

		workers.getBaseURL = function() {
        	var url = this.config.hasAudioBaseUrl ? this.config.baseURL : this.config.teiRepo ? '/tei/' : '/client/' ;
        	// console.log('workers.getBaseURL'
        	// 	,' url:',url
        	// 	,', this.config.hasAudioBaseUrl:',this.config.hasAudioBaseUrl
        	// 	,', this.config.baseUrl:',this.config.baseURL
        	// 	,', this.config.teiRepo:', this.config.teiRepo
        	// );
        	return url;
        }

        workers.setConfig = function( config ) {
        	this.config = config;
        	//console.log('this.config:',this.config);
        }
		// ---------------------------------------------------------------
        //                     Ogg Opus Encoder
        // ---------------------------------------------------------------
		workers.oggopusEncoder = function() {
			this.onmessage = function( e ){
			  //this.console.log('--- worker > onmessage, cmd:',e.data.cmd);
			  switch( e.data.cmd ) {

			    case 'encodeAll':
			      this.encoder.encodeAll( e.data.buffers );
			      break;

			    case 'encode':
			      this.encoder.encode( e.data.buffers );
			      break;

			    case 'done':
			      this.encoder.encodeFinalFrame();
			      this.close();
			      break;

			    case 'init':
			      var url = e.data.baseURL + 'public/javascripts/recorder/';
			      //console.log('oggopusEncoder, url:',url);
			      importScripts( url+'libopus.js', url+'resampler.js' );
			      this.encoder = new OggOpusEncoder( e.data, this );
			      break;
			  }
			};

			this.log = function() {
				// var msg = Array.prototype.slice.call(arguments);
				// msg = msg.join('');
				// this.postMessage( {cmd:'log', msg: msg} );
			};

			var OggOpusEncoder = function( config, worker ){
			  this.worker = worker;
			  this.numberOfChannels = config.numberOfChannels || 1;
			  this.originalSampleRate = config.originalSampleRate;
			  this.encoderSampleRate = config.encoderSampleRate || 48000;
			  this.maxBuffersPerPage = config.maxBuffersPerPage || 40; // Limit latency for streaming
			  this.encoderApplication = config.encoderApplication || 2048; // 2048 = Voice, 2049 = Full Band Audio, 2051 = Restricted Low Delay
			  this.encoderFrameSize = config.encoderFrameSize || 20; // 20ms frame
			  this.bitRate = config.bitRate;

			  //this.worker.postMessage( {cmd:'log', msg:'this.encoderSampleRate:'+this.encoderSampleRate+', this.originalSampleRate:'+this.originalSampleRate+', this.numberOfChannels:'+this.numberOfChannels} );

			  this.resampler = new Resampler({
			    resampledRate: this.encoderSampleRate,
			    originalSampleRate: this.originalSampleRate,
			    numberOfChannels: this.numberOfChannels
			  });

			  this.pageIndex = 0;
			  this.granulePosition = 0;
			  this.segmentData = new Uint8Array( 65025 );
			  this.segmentDataIndex = 0;
			  this.segmentTable = new Uint8Array( 255 );
			  this.segmentTableIndex = 0;
			  this.buffersInPage = 0;

			  this.initChecksumTable();
			  this.initCodec();
			  this.generateIdPage();
			  this.generateCommentPage();

			  if ( this.numberOfChannels === 1 ) {
			    this.interleave = function( buffers ) { return buffers[0]; };
			  }
			};

			OggOpusEncoder.prototype.encodeAll = function( buffers ) {
			 //this.worker.console.log('opus worker > encodeAll');

			  for (var i=0; i<buffers.length; i++) {
			    //this.worker.console.log('encodeAll > buffers[',i,']:',buffers[i]);
			    this.encode( [ buffers[i] ] );
			  }

			  this.encodeFinalFrame();
			  this.worker.close();
			};

			// this expects ScriptProcessorNode.onaudioprocess AudioProcessingEvent inputBuffer (e.inputBuffer - AudioBuffer)
			OggOpusEncoder.prototype.encode = function( buffers ) {
			  //this.worker.console.log('opus worker > encode, buffers:',buffers);
			  var samples = this.resample( buffers );
			  //this.worker.console.log('        samples:',samples);
			  samples = this.interleave( samples );
			  //this.worker.console.log('        samples:',samples);
			  var sampleIndex = 0;

			  //this.worker.console.log('opus worker > encode, buffers.length:',buffers.length,', this.buffersInPage:',this.buffersInPage,', samples.length:',samples.length );

			  while ( sampleIndex < samples.length ) {

			    var lengthToCopy = Math.min( this.encoderBufferLength - this.encoderBufferIndex, samples.length - sampleIndex );
			    this.encoderBuffer.set( samples.subarray( sampleIndex, sampleIndex+lengthToCopy ), this.encoderBufferIndex );
			    sampleIndex += lengthToCopy;
			    this.encoderBufferIndex += lengthToCopy;

			    if ( this.encoderBufferIndex === this.encoderBufferLength ) {
			      var packetLength = _opus_encode_float( this.encoder, this.encoderBufferPointer, this.encoderSamplesPerChannelPerPacket, this.encoderOutputPointer, this.encoderOutputMaxLength );
			      this.segmentPacket( packetLength );
			      this.encoderBufferIndex = 0;
			    }
			  }

			  this.buffersInPage++;

			  if ( this.buffersInPage >= this.maxBuffersPerPage ) {
			    this.generatePage();
			  }
			};

			OggOpusEncoder.prototype.encodeFinalFrame = function() {
			  //this.worker.console.log('opus worker > encodeFinalFrame' );

			  this.encode( [ new Float32Array( this.encoderBufferLength - this.encoderBufferIndex ) ] );
			  this.headerType += 4;
			  this.generatePage();
			};

			OggOpusEncoder.prototype.getChecksum = function( data ){
			  //this.worker.console.log('opus worker > getChecksum' );

			  var checksum = 0;
			  for ( var i = 0; i < data.length; i++ ) {
			    checksum = (checksum << 8) ^ this.checksumTable[ ((checksum>>>24) & 0xff) ^ data[i] ];
			  }
			  return checksum >>> 0;
			};

			OggOpusEncoder.prototype.generateCommentPage = function(){
			  // this.worker.console.log('opus worker > generateCommentPage' );

			  var segmentDataView = new DataView( this.segmentData.buffer );
			  segmentDataView.setUint32( 0, 1937076303, true ); // Magic Signature 'Opus'
			  segmentDataView.setUint32( 4, 1936154964, true ); // Magic Signature 'Tags'
			  segmentDataView.setUint32( 8, 8, true ); // Vendor Length
			  segmentDataView.setUint32( 12, 1868784978, true ); // Vendor name 'Reco'
			  segmentDataView.setUint32( 16, 1919247474, true ); // Vendor name 'rder'
			  segmentDataView.setUint32( 20, 0, true ); // User Comment List Length
			  this.segmentTableIndex = 1;
			  this.segmentDataIndex = this.segmentTable[0] = 24;
			  this.headerType = 0;
			  this.generatePage();
			};

			OggOpusEncoder.prototype.generateIdPage = function(){
			  // this.worker.console.log('opus worker > generateIdPage' );

			  var segmentDataView = new DataView( this.segmentData.buffer );
			  segmentDataView.setUint32( 0, 1937076303, true ); // Magic Signature 'Opus'
			  segmentDataView.setUint32( 4, 1684104520, true ); // Magic Signature 'Head'
			  segmentDataView.setUint8( 8, 1, true ); // Version
			  segmentDataView.setUint8( 9, this.numberOfChannels, true ); // Channel count
			  segmentDataView.setUint16( 10, 3840, true ); // pre-skip (80ms)
			  segmentDataView.setUint32( 12, this.originalSampleRate, true ); // original sample rate
			  segmentDataView.setUint16( 16, 0, true ); // output gain
			  segmentDataView.setUint8( 18, 0, true ); // channel map 0 = mono or stereo
			  this.segmentTableIndex = 1;
			  this.segmentDataIndex = this.segmentTable[0] = 19;
			  this.headerType = 2;
			  this.generatePage();
			};

			OggOpusEncoder.prototype.generatePage = function(){
			  // this.worker.console.log('opus worker > generatePage' );

			  var granulePosition = ( this.lastPositiveGranulePosition === this.granulePosition) ? -1 : this.granulePosition;
			  var pageBuffer = new ArrayBuffer(  27 + this.segmentTableIndex + this.segmentDataIndex );
			  var pageBufferView = new DataView( pageBuffer );
			  var page = new Uint8Array( pageBuffer );

			  pageBufferView.setUint32( 0, 1399285583, true); // Capture Pattern starts all page headers 'OggS'
			  pageBufferView.setUint8( 4, 0, true ); // Version
			  pageBufferView.setUint8( 5, this.headerType, true ); // 1 = continuation, 2 = beginning of stream, 4 = end of stream

			  // Number of samples upto and including this page at 48000Hz, into 64 bits
			  pageBufferView.setUint32( 6, granulePosition, true );
			  if ( granulePosition > 4294967296 || granulePosition < 0 ) {
			    pageBufferView.setUint32( 10, Math.floor( granulePosition/4294967296 ), true );
			  }

			  pageBufferView.setUint32( 14, 0, true ); // Bitstream serial number
			  pageBufferView.setUint32( 18, this.pageIndex++, true ); // Page sequence number
			  pageBufferView.setUint8( 26, this.segmentTableIndex, true ); // Number of segments in page.
			  page.set( this.segmentTable.subarray(0, this.segmentTableIndex), 27 ); // Segment Table
			  page.set( this.segmentData.subarray(0, this.segmentDataIndex), 27 + this.segmentTableIndex ); // Segment Data
			  pageBufferView.setUint32( 22, this.getChecksum( page ), true ); // Checksum

			  this.worker.postMessage( page.buffer );
			  this.segmentTableIndex = 0;
			  this.segmentDataIndex = 0;
			  this.buffersInPage = 0;
			  if ( granulePosition > 0 ) {
			    this.lastPositiveGranulePosition = granulePosition;
			  }
			};

			OggOpusEncoder.prototype.initChecksumTable = function(){
			  // this.worker.console.log('opus worker > initChecksumTable' );
			  this.checksumTable = [];
			  for ( var i = 0; i < 256; i++ ) {
			    var r = i << 24;
			    for ( var j = 0; j < 8; j++ ) {
			      r = ((r & 0x80000000) != 0) ? ((r << 1) ^ 0x04c11db7) : (r << 1);
			    }
			    this.checksumTable[i] = (r & 0xffffffff);
			  }
			};

			OggOpusEncoder.prototype.initCodec = function() {
			  // this.worker.console.log('opus worker > initCodec' );
			  this.encoder = _opus_encoder_create( this.encoderSampleRate, this.numberOfChannels, this.encoderApplication, allocate(4, 'i32', ALLOC_STACK) );

			  if ( this.bitRate ) {
			    var bitRateLocation = _malloc( 4 );
			    HEAP32[bitRateLocation >>> 2] = this.bitRate;
			    _opus_encoder_ctl( this.encoder, 4002, bitRateLocation );
			    _free( bitRateLocation );
			  }

			  this.encoderBufferIndex = 0;
			  this.encoderSamplesPerChannelPerPacket = this.encoderSampleRate * this.encoderFrameSize / 1000;
			  this.encoderBufferLength = this.encoderSamplesPerChannelPerPacket * this.numberOfChannels;
			  this.encoderBufferPointer = _malloc( this.encoderBufferLength * 4 ); // 4 bytes per sampled
			  this.encoderBuffer = HEAPF32.subarray( this.encoderBufferPointer >> 2, (this.encoderBufferPointer >> 2) + this.encoderBufferLength );
			  this.encoderOutputMaxLength = 4000;
			  this.encoderOutputPointer = _malloc( this.encoderOutputMaxLength );
			  this.encoderOutputBuffer = HEAPU8.subarray( this.encoderOutputPointer, this.encoderOutputPointer + this.encoderOutputMaxLength );
			};

			OggOpusEncoder.prototype.interleave = function( buffers ) {
			  //this.worker.console.log('opus worker > interleave, buffers[0].length:',buffers[0].length );
			  var outputData = new Float32Array( buffers[0].length * this.numberOfChannels );

			  for ( var i = 0; i < buffers[0].length; i++ ) {
			    for ( var channel = 0; channel < this.numberOfChannels; channel++ ) {
			      outputData[ i * this.numberOfChannels + channel ] = buffers[ channel ][ i ];
			    }
			  }

			  return outputData;
			};

			OggOpusEncoder.prototype.resample = function( buffers ) {
			  var resampledBuffers = [];
			  for ( var channel = 0; channel < this.numberOfChannels; channel++ ) {
			    resampledBuffers.push( this.resampler.resample( buffers[channel], channel ) );
			  }
			  return resampledBuffers;
			};

			OggOpusEncoder.prototype.segmentPacket = function( packetLength ) {
			  //this.worker.console.log('opus worker > segmentPacket, packetLength:',packetLength );
			  var packetIndex = 0;

			  while ( packetLength >= 0 ) {

			    if ( this.segmentTableIndex === 255 ) {
			      this.generatePage();
			      this.headerType = 1;
			    }

			    var segmentLength = Math.min( packetLength, 255 );
			    this.segmentTable[ this.segmentTableIndex++ ] = segmentLength;
			    this.segmentData.set( this.encoderOutputBuffer.subarray( packetIndex, packetIndex + segmentLength ), this.segmentDataIndex );
			    this.segmentDataIndex += segmentLength;
			    packetIndex += segmentLength;
			    packetLength -= 255;
			  }

			  this.granulePosition += ( 48 * this.encoderFrameSize );
			  if ( this.segmentTableIndex === 255 ) {
			    this.generatePage();
			    this.headerType = 0;
			  }
			};
		};

		// ---------------------------------------------------------------
        //                     Ogg Opus Decoder
        // ---------------------------------------------------------------
		workers.oggopusDecoder = function() {
			this.onmessage = function( e ){
			  switch( e.data.cmd ){

			    case 'decode':
			      this.log('oggopusDecoder > decode, e.data.pages:',e.data.pages);
			      this.decoder.decode( e.data.pages );
			      break;

			    case 'done':
			      this.log('oggopusDecoder > done');
			      this.decoder.sendLastBuffer();
			      this.close();
			      break;

			    case 'init':
			      var url = e.data.baseURL + 'public/javascripts/recorder/';
			      importScripts( url+'libopus.js', url+'resampler.js' );
			      this.decoder = new OggOpusDecoder( e.data, this );
			      this.log('oggopusDecoder > init, this.decoder:',this.decoder);
			      break;

			  }
			};

			this.log = function() {
				var msg = Array.prototype.slice.call(arguments);
				msg = msg.join('');
				this.postMessage( {cmd:'log', msg: msg} );
			};

			var OggOpusDecoder = function( config, worker ){
			  this.worker = worker;
			  this.worker.log('new OggOpusDecoder');
			  this.bufferLength = config.bufferLength || 4096;
			  this.decoderSampleRate = config.decoderSampleRate || 48000;
			  this.outputBufferSampleRate = config.outputBufferSampleRate || 48000;
			  this.outputBuffers = [];
			};

			OggOpusDecoder.prototype.decode = function( typedArray ) {
			  var dataView = new DataView( typedArray.buffer );
			  this.worker.log('OggOpusDecoder > typedArray:',typedArray,', dataView:',dataView);
			  this.getPageBoundaries( dataView ).map( function( pageStart ) {
			    var headerType = dataView.getUint8( pageStart + 5, true );
			    var pageIndex = dataView.getUint32( pageStart + 18, true );

			    // Beginning of stream
			    if ( headerType & 2 ) {
			      this.numberOfChannels = dataView.getUint8( pageStart + 37, true );
			      this.init();
			    }
			    // Decode page
			    if ( pageIndex > 1 ) {
			      var segmentTableLength = dataView.getUint8( pageStart + 26, true );
			      var segmentTableIndex = pageStart + 27 + segmentTableLength;

			      for ( var i = 0; i < segmentTableLength; i++ ) {
			        var packetLength = dataView.getUint8( pageStart + 27 + i, true );
			        this.decoderBuffer.set( typedArray.subarray( segmentTableIndex, segmentTableIndex += packetLength ), this.decoderBufferIndex );
			        this.decoderBufferIndex += packetLength;

			        if ( packetLength < 255 ) {
			          var outputSampleLength = _opus_decode_float( this.decoder, this.decoderBufferPointer, this.decoderBufferIndex, this.decoderOutputPointer, this.decoderOutputMaxLength, 0);
			          this.sendToOutputBuffers( this.decoderOutputBuffer.subarray( 0, outputSampleLength * this.numberOfChannels ) );
			          this.decoderBufferIndex = 0;
			        }
			      }
			    }

			    // End of stream
			    if ( headerType & 4 ) {
			      this.sendLastBuffer();
			      this.worker.close();
			    }
			  }, this );
			};

			OggOpusDecoder.prototype.deinterleave = function( mergedBuffers ) {
			  var deinterleavedData = [];
			  var deinterleavedDataIndex = 0;

			  for ( var i = 0; i < this.numberOfChannels; i++ ) {
			    deinterleavedData.push( new Float32Array( mergedBuffers.length / this.numberOfChannels ) );
			  }

			  for ( var i = 0; i < mergedBuffers.length; i++ ) {
			    var channel = i % this.numberOfChannels;
			    deinterleavedData[ channel ][ deinterleavedDataIndex ] = mergedBuffers[ i ];
			    deinterleavedDataIndex += ( channel == deinterleavedData.length - 1 ) ? 1 : 0;
			  }

			  return deinterleavedData;
			};

			OggOpusDecoder.prototype.getPageBoundaries = function( dataView ){
			  var pageBoundaries = [];

			  for ( var i = 0; i < dataView.byteLength - 32; i++ ) {
			    if ( dataView.getUint32( i, true ) == 1399285583 ) {
			      pageBoundaries.push( i );
			    }
			  }

			  return pageBoundaries;
			};

			OggOpusDecoder.prototype.init = function(){
			  this.resetOutputBuffers();
			  this.initCodec();

			  this.resampler = new Resampler({
			    resampledRate: this.outputBufferSampleRate,
			    originalSampleRate: this.decoderSampleRate,
			    numberOfChannels: this.numberOfChannels
			  });

			  if ( this.numberOfChannels === 1 ) {
			    this.deinterleave = function( mergedBuffers ) { return [mergedBuffers]; };
			  }
			};

			OggOpusDecoder.prototype.initCodec = function() {
			  this.decoder = _opus_decoder_create( this.decoderSampleRate, this.numberOfChannels, allocate(4, 'i32', ALLOC_STACK) );
			  this.decoderBufferMaxLength = 4000;
			  this.decoderBufferPointer = _malloc( this.decoderBufferMaxLength );
			  this.decoderBuffer = HEAPU8.subarray( this.decoderBufferPointer, this.decoderBufferPointer + this.decoderBufferMaxLength );
			  this.decoderBufferIndex = 0;
			  this.decoderOutputMaxLength = this.decoderSampleRate * this.numberOfChannels * 120 / 1000; // Max 120ms frame size
			  this.decoderOutputPointer = _malloc( this.decoderOutputMaxLength * 4 ); // 4 bytes per sample
			  this.decoderOutputBuffer = HEAPF32.subarray( this.decoderOutputPointer >> 2, ( this.decoderOutputPointer >> 2 ) + this.decoderOutputMaxLength );
			};

			OggOpusDecoder.prototype.resetOutputBuffers = function(){
			  this.outputBuffers = [];
			  this.outputBufferArrayBuffers = [];
			  this.outputBufferIndex = 0;

			  for ( var i = 0; i < this.numberOfChannels; i++ ) {
			    this.outputBuffers.push( new Float32Array( this.bufferLength ) );
			    this.outputBufferArrayBuffers.push( this.outputBuffers[i].buffer );
			  }
			};

			OggOpusDecoder.prototype.sendLastBuffer = function(){
			  this.sendToOutputBuffers( new Float32Array( ( this.bufferLength - this.outputBufferIndex ) * this.numberOfChannels ), true );
			};

			OggOpusDecoder.prototype.sendToOutputBuffers = function( mergedBuffers, lastBuffer ){
			  lastBuffer = lastBuffer || false;
			  this.worker.log('OggOpusDecoder > sendToOutputBuffers, lastBuffer:',lastBuffer);
			  var data = this.deinterleave( mergedBuffers );
			  var dataIndex = 0;

			  for ( var channel = 0; channel < data.length; channel++ ) {
			    data[ channel ] = this.resampler.resample( data[ channel ], channel );
			  }

			  while ( dataIndex < data[0].length ) {
			    var amountToCopy = Math.min( data[0].length - dataIndex, this.bufferLength - this.outputBufferIndex );

			    for ( var i = 0; i < data.length; i++ ) {
			      this.outputBuffers[i].set( data[i].subarray( dataIndex, dataIndex + amountToCopy ), this.outputBufferIndex );
			    }

			    this.outputBufferIndex += amountToCopy;
			    dataIndex += amountToCopy;
			    if ( this.outputBufferIndex == this.bufferLength || lastBuffer ) {
			      this.worker.log('OggOpusDecoder > this.outputBufferIndex:',this.outputBufferIndex,', this.bufferLength:',this.bufferLength);
			      var o = { outputBuffer: this.outputBuffers[0].buffer,
			                cmd: lastBuffer ? 'decoded' : 'decode' };
			      this.worker.postMessage( o );
			      this.resetOutputBuffers();
			    }
			  }
			};
		};

		// ---------------------------------------------------------------
        //                     Wav Encoder
        // ---------------------------------------------------------------

        workers.wavEncoder = function() {
        	this.onmessage = function( e ){
			  switch( e.data.cmd ){
			    case 'encode':
			      this.encoder.encode( e.data.samples);
			      break;
			    case 'close':
			      this.close();
			      break;
			    case 'init':
			      this.encoder = new WavEncoder( this );
			      break;
			  }
			};

			this.log = function() {
				var msg = Array.prototype.slice.call(arguments);
				msg = msg.join('');
				this.postMessage( {cmd:'log', msg: msg} );
			};

			var WavEncoder = function( worker ){
			  this.worker = worker;
			};

			WavEncoder.prototype.encode = function( samples ) {
			  var numChannels = 2;
			  samples = this.interleave( samples, samples );
			  var buffer = new ArrayBuffer( 44 + samples.length * 2 );
			  var sampleRate = 44100;
			  var view = new DataView( buffer );

			  /* RIFF identifier */
			  this.writeString( view, 0, 'RIFF' );
			  /* RIFF chunk length */
			  view.setUint32( 4, 36 + samples.length * 2, true );
			  /* RIFF type */
			  this.writeString( view, 8, 'WAVE' );
			  /* format chunk identifier */
			  this.writeString( view, 12, 'fmt ' );
			  /* format chunk length */
			  view.setUint32( 16, 16, true );
			  /* sample format (raw) */
			  view.setUint16( 20, 1, true );
			  /* channel count */
			  view.setUint16( 22, numChannels, true );
			  /* sample rate */
			  view.setUint32( 24, sampleRate, true );
			  /* byte rate (sample rate * block align) */
			  view.setUint32( 28, sampleRate * 4, true );
			  /* block align (channel count * bytes per sample) */
			  view.setUint16( 32, 4, true );
			  /* bits per sample */
			  view.setUint16( 34, 16, true );
			  /* data chunk identifier */
			  this.writeString( view, 36, 'data' );
			  /* data chunk length */
			  view.setUint32( 40, samples.length * 2, true );

			  this.floatTo16BitPCM( view, 44, samples );

			  this.worker.postMessage( {cmd:'encoded', data: view.buffer} );
			};

			WavEncoder.prototype.interleave = function ( inputL, inputR ) {
			    var length = inputL.length + inputR.length;
			    var result = new Float32Array( length );
			    var index = 0,
			    inputIndex = 0;

			    while ( index < length ) {
			        result[ index++ ] = inputL[ inputIndex ];
			        result[ index++ ] = inputR[ inputIndex ];
			        inputIndex++;
			    }
			    return result;
			};

			WavEncoder.prototype.floatTo16BitPCM = function( output, offset, input ) {
			    for ( var i = 0; i < input.length; i++, offset += 2 ) {
			        var s = Math.max( -1, Math.min( 1, input[ i ] ) );
			        output.setInt16( offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true );
			    }
			};

			WavEncoder.prototype.writeString = function ( view, offset, string ) {
			    for ( var i = 0; i < string.length; i++ ){
			        view.setUint8( offset + i, string.charCodeAt( i ) );
			    }
			};
        };

        workers.createWorker = function( name, useBlob ) {
    	    useBlob = useBlob || false;
            var url;
            var worker;
            var loadFrom = useBlob ? 'blob' : 'loaded .js';
            try {
                if ( useBlob ) {
                    url = URL.createObjectURL( new Blob([ '(', workers[name].toString(), ')()' ], { type: 'application/javascript' }) );
                } else {
                    url = this.getBaseURL() + 'public/javascripts/recorder/' + name + '.js';
                }
                worker = new Worker( url );
            } catch (e ) {
                console.log('ERROR! Worker-Functions >',name,' create worker from',loadFrom,' e:',e);
                if ( useBlob === true ) {
                	// if we tried to invoke using blob and it fails,
                	// set config.useBlob to false to avoid that for future web worker invocations
                	if ( this.config ) {
                		this.config.useBlob = false;
                	}
                    url = this.getBaseURL() + 'public/javascripts/recorder/' + name + '.js';
                    worker = new Worker( url );
                }
            }
            //console.log('Worker-Functions > createWorker, name:',name,', useBlob:',useBlob,', worker:',worker);
            return worker;
        };

		return workers;
});
// @license http://opensource.org/licenses/MIT
// copyright Paul Irish 2015


// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill
//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js
// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values

// if you want values similar to what you'd get with real perf.now, place this towards the head of the page
// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed


(function(){

  if ("performance" in window == false) {
      window.performance = {};
  }

  Date.now = (Date.now || function () {  // thanks IE8
	  return new Date().getTime();
  });

  if ("now" in window.performance == false){

    var nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart;
    }

    window.performance.now = function now(){
      return Date.now() - nowOffset;
    };
  }

})();
define("../../libs/performance-now-polyfill", function(){});

define(
    'encoder',[
        'worker-functions',
        '../../libs/performance-now-polyfill'
    ],
    function( WorkerFunctions ) {
        function Encoder( $container, config ) {

            var baseURL = config.baseURL;
            var wavEncoder = null;
            var opusEncoder = null;
            var useBlob = config.useBlob;
            var opusInitConfig = {
                cmd: 'init',
                bufferLength: config.recordingOptions.bufferSize, //2048, //4096,
                monitorGain: 0,
                numberOfChannels: config.recordingOptions.numInputChannels,
                //originalSampleRate: config.recordingOptions.sampleRate,
                encoderSampleRate: 48000,
                stream: false,
                maxBuffersPerPage: 40,
                encoderApplication: 2048,
                encoderFrameSize: 20,
                streamOptions: {
                    optional: [],
                    mandatory: {
                        googEchoCancellation: false,
                        googAutoGainControl: false,
                        googNoiseSuppression: false,
                        googHighpassFilter: false
                    }
                },
                baseURL: baseURL
            };

            WorkerFunctions.setConfig( config );

            function getBaseURL() {
                return config.baseURL; //(config.teiRepo ? config.baseURL : '');
            }

            function finalize() {
                terminateAll();
                opusEncoder = null;
                wavEncoder = null;
            }

            function terminateAll() {
                $.each( [wavEncoder, opusEncoder], function (idx, encoder ) {
                    if ( encoder ) {
                        encoder.terminate();
                    }
                });
            }

            function encode( codec, format, samples, progressive, end ) {
                //console.log('encode, codec:',codec,', samples:',samples);
                switch ( codec ) {
                    case 'wav':
                        return encodeWAV( samples );
                    case 'spx':
                        return encodeSPXB64( samples, 9);
                    case 'opus':
                        return encodeOpus( samples, progressive, end );
                    default:
                        console.error('Audio Recorder Encoder > codec:',codec,', is unsupported');
                }
            }

            function encodeB64( bytes ) {
                var binary = '';
                for( var i = 0; i < bytes.length; i++ ) {
                    binary += String.fromCharCode( bytes[ i ] );
                }
                var b64 = window.btoa( binary ).replace(/\s+/g, '');
                return b64;
            }

            function parseWav(wav) {
                function readInt(i, bytes) {
                    var ret = 0,
                        shft = 0;

                    while (bytes) {
                        ret += wav[i] << shft;
                        shft += 8;
                        i++;
                        bytes--;
                    }
                    return ret;
                }
                if (readInt(20, 2) != 1) throw 'Invalid compression code, not PCM';
                if (readInt(22, 2) != 1) throw 'Invalid number of channels, not 1';
                return {
                    sampleRate: readInt(24, 4),
                    bitsPerSample: readInt(34, 2),
                    samples: wav.subarray(44)
                };
            }

            function Uint8ArrayToFloat32Array(u8a){
                //console.log('Uint8ArrayToFloat32Array, u8a.length:',u8a.length);
                var f32Buffer = new Float32Array(u8a.length);
                for (var i = 0; i < u8a.length; i++) {
                    var value = u8a[i<<1] + (u8a[(i<<1)+1]<<8);
                    if (value >= 0x8000) value |= ~0x7FFF;
                    f32Buffer[i] = value / 0x8000;
                }
                return f32Buffer;
            }

            // ---------------------------------------------------------------
            //     encode opus B64, progressive and non-progressive
            // ---------------------------------------------------------------

            var encodeOpus = (function(){
                var recordedPages = [];
                var totalLength = 0;
                var deferred;
                var useBlob = true;
                var workerBlob;
                return function( buffers, progressive, end ) {
                    // lazily instantiate opus encoder
                    if ( !opusEncoder ) {
                        recordedPages = [];
                        totalLength = 0;
                        deferred = $.Deferred();
                        opusEncoder = WorkerFunctions.createWorker( 'oggopusEncoder', config.useBlob ); //createWorker( 'oggopusEncoder' )
                        var initConfig = $.extend( {}, opusInitConfig );
                        initConfig.originalSampleRate = config.recordingOptions.sampleRate;
                        // post init message
                        opusEncoder.postMessage( initConfig );
                        // handler for worker message
                        var onPageEncoded = function( pageBuffer ) {
                            var page = new Uint8Array( pageBuffer );
                            recordedPages.push( page );
                            totalLength += page.length;
                            // Stream is finished
                            if ( page[5] & 4 ) {
                                var outputData = new Uint8Array( totalLength );
                                var outputIndex = 0;
                                for ( var i = 0; i < recordedPages.length; i++ ) {
                                  outputData.set( recordedPages[i], outputIndex );
                                  outputIndex += recordedPages[i].length;
                                }
                                // var blob =  new Blob( [outputData], { type: "audio/ogg" } );
                                var b64 = encodeB64( outputData );
                                recordedPages = [];
                                // cleanup encoder worker
                                opusEncoder.terminate();
                                opusEncoder.onmessage = null;
                                opusEncoder.onerror = null;
                                opusEncoder = null;
                                deferred.resolve( b64 );//, blob );
                                deferred = null;
                            }
                        };

                        // worker message handler
                        opusEncoder.onmessage = function( e ) {
                            var data = e.data;
                            switch ( data.cmd ) {
                                case 'log':
                                        console.log( data.msg );
                                        break;
                                default:
                                    onPageEncoded( data );
                            }
                        };
                        // worker error handler TODO: better error handling
                        opusEncoder.onerror = function( e ) {
                            console.error('Audio recorder > opusEncoder error:',e.message);
                        };
                    }
                    if ( progressive ) {
                        if ( end ) {
                            opusEncoder.postMessage( { cmd: 'done' } );
                        } else {
                            opusEncoder.postMessage( { cmd: 'encode', buffers: buffers } );
                        }
                    } else {
                        opusEncoder.postMessage( { cmd: 'encodeAll', buffers: buffers } );
                    }
                    return deferred;
                };
            })();

            // ---------------------------------------------------------------
            //                     encode WAV raw data
            // ---------------------------------------------------------------

            function encodeWAV( samples ) {
                wavEncoder = WorkerFunctions.createWorker( 'wavEncoder', config.useBlob );
                var deferred = $.Deferred();
                // worker message handler
                wavEncoder.onmessage = function( e ) {
                    var data = e.data;
                    switch ( data.cmd ) {
                        case 'close':
                            //console.log( 'close' );
                            break;
                        case 'encoded':
                            var wav = e.data.data;
                            wavEncoder.terminate();
                            deferred.resolve( wav );
                            break;
                    }
                };
                // worker error handler TODO: better error handling
                wavEncoder.onerror = function( e ) {
                    console.error('Audio recorder > wavEncoder error:',e.message);
                };
                // init the worker and then encode
                wavEncoder.postMessage( {cmd: 'init'} );
                wavEncoder.postMessage( { cmd: 'encode', samples: samples, baseURL: baseURL } );

                return deferred;
            }

            // ---------------------------------------------------------------
            //                     returned public API
            // ---------------------------------------------------------------

            return {
                encode: encode,
                terminateAll: terminateAll,
                finalize: finalize
            };

        }

        return Encoder;
});

define(
    'decoder',[
        'worker-functions'
    ],
    function( WorkerFunctions ) {
        function Decoder( $container, config) {

            var opusDecoder = null;
            var baseURL = config.baseURL;

            WorkerFunctions.setConfig( config );

            function getBaseURL() {
                return config.baseURL; // (config.teiRepo ? config.baseURL : '');
            }

            function finalize() {
                terminateAll();
                opusDecoder = null;
            }

            function terminateAll() {
                $.each( [opusDecoder], function (idx, decoder ) {
                    if ( decoder ) {
                        decoder.terminate();
                    }
                });
            }

            // base64 to byte array
            function decodeB64( b64 ) {
                var byteCharacters = atob(b64);
                var byteNumbers = new Array(byteCharacters.length);
                for (var i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                var byteArray = new Uint8Array(byteNumbers);
                return byteArray;
            }

            function decode( codec, b64 ) {
                switch ( codec ) {
                    case 'spx':
                        return decodeSPXB64( b64 );
                    case 'opus':
                        return decodeOpus( b64 );
                    default:
                        console.error('Audio Recorder Encoder > codec:',codec,', is unsupported');
                }
            }
            // ---------------------------------------------------------------
            //                     decode opus
            // ---------------------------------------------------------------

            function decodeOpus( b64 ) {
                var buffers = [];
                var recLen = 0;
                var deferred = $.Deferred();
                opusDecoder = WorkerFunctions.createWorker( 'oggopusDecoder', config.useBlob );
                var initConfig = {
                    cmd: 'init',
                    bufferLength: config.recordingOptions.bufferSize, //2048, //4096,
                    // decoderSampleRate: 48000,
                    outputBufferSampleRate: config.recordingOptions.sampleRate, //44100, //48000
                    baseURL: baseURL
                };
                // worker message handler
                opusDecoder.onmessage = function( e ) {
                    var data = e.data;
                    switch ( data.cmd ) {
                        case 'log':
                            console.log( data.msg );
                            break;
                        case 'decode':
                            buffers.push( new Float32Array(data.outputBuffer) );
                            recLen += initConfig.bufferLength;
                            break;
                        case 'decoded':
                            buffers.push( new Float32Array(data.outputBuffer) );
                            recLen += initConfig.bufferLength;
                            opusDecoder.terminate();
                            samples = mergeBuffers( buffers, recLen );
                            deferred.resolve( samples );
                            break;
                    }
                };
                // worker error handler TODO: better error handling
                opusDecoder.onerror = function( e ) {
                    console.error('Audio recorder > opusDecoder error:',e);
                };
                // init the worker and then encode
                opusDecoder.postMessage( initConfig );
                opusDecoder.postMessage( { cmd: 'decode', pages: decodeB64(b64), baseURL: baseURL } );

                return deferred;
            }

            function mergeBuffers( buffers, len ) {
                var result = new Float32Array( len );
                var offset = 0;
                for( var i = 0; i < buffers.length; i++ ) {
                    var buffer = buffers[ i ];
                    result.set( buffer, offset );
                    offset += buffer.length;
                }
                return result;
            }

            // ---------------------------------------------------------------
            //                     returned public API
            // ---------------------------------------------------------------

            return {
                decode: decode,
                finalize: finalize,
                terminateAll: terminateAll
            };
        }

        return Decoder;
});

define(
    'webrtc-recorder',[
        'encoder'
    ],
    function( Encoder ) {
        function WebRTCRecorder( $container, config ) {

            var _buffers, _recLen, _initDeferred; // _scriptProcessorNode, _sourceNode, _stream;

            // no waiting for initialization here
            _initDeferred = $.Deferred();
            _initDeferred.resolve();

            /**********************************************************
             *                 public API methods
             **********************************************************/

            function startRecording() {
                clearRawData();

                if ( window.TN8 && window.TN8.AudioNode ) {
                    onRecordingStart();
                }
                else {
                    navigator.getUserMedia( { audio: true }, successCallback, errorCallback );
                    // $(window).off('click.audioRecorder')
                    //     .on('click.audioRecorder', function( e ) {
                    //         navigator.getUserMedia( { audio: true }, successCallback, errorCallback );
                    //     });
                }
            }

            function getAudioContext() {
                window.TN8 = window.TN8 || {};
                if ( !window.TN8.AudioContext ) {
                    var AudioContext = window.AudioContext || window.webkitAudioContext;
                    window.TN8.AudioContext = new AudioContext();
                }
                return window.TN8.AudioContext
            }

            function onRecordingStart() {
                window.TN8.AudioNode.onaudioprocess = onAudioInput;
                $container.trigger( 'audioenabled' );
            }

            function getSampleRate() {
                return getAudioContext().sampleRate;
            }

            function stopRecording() {
                //_scriptProcessorNode.disconnect();
                window.TN8.AudioNode.onaudioprocess = null;
            }

            function getRawData( unmerged ) {
                if ( unmerged ) {
                    return _buffers;
                } else {
                    return mergeBuffers( _buffers, _recLen );
                }
            }

            function hasRawData() {
                return  typeof _buffers !== 'undefined' && Object.prototype.toString.call(_buffers) === '[object Array]' && _buffers.length > 0 && _recLen > 0;
                //return  'typeof _buffers !== undefined' && _buffers.length > 0 && _recLen > 0;
            }

            function onAudioRemoved() {
                clearRawData();
            }

            function finalize() {
                _buffers = null;
                _encoder = null;
                $container = null;
            }

            /**********************************************************
             *                 event handlers
             **********************************************************/

            // node onaudioprocess handler
            function onAudioInput( e ) {
                var buffer = e.inputBuffer.getChannelData( 0 );
                _buffers.push( new Float32Array( buffer ) );
                _recLen += config.recordingOptions.bufferSize; //2048;
                $container.trigger( "audioinput", [ buffer ] );
            }

            /**********************************************************
             *   navigator.getUserMedia() success/failure callbacks
             **********************************************************/

            function successCallback( stream ) {
                //$(window).off('click.audioRecorder');

                var audioContext = getAudioContext();
                var options = config.recordingOptions || {};
                var sourceNode = audioContext.createMediaStreamSource( stream );
                var scriptProcessorNode = audioContext.createScriptProcessor( options.bufferSize, options.numInputChannels, options.numOutputChannels); //2048, 1, 1 )
                sourceNode.connect( scriptProcessorNode );
                scriptProcessorNode.connect( audioContext.destination );

                // store values in TN8 object to mimick client behavior
                window.TN8 = window.TN8 || {};
                window.TN8.AudioNode = window.TN8.AudioNode || scriptProcessorNode;
                window.mediaStreamGlobal = window.mediaStreamGlobal || sourceNode;

                //console.log('----- navigator.getUserMedia success');
                onRecordingStart();
            }

            function errorCallback( error ) {
                //console.log('----- navigator.getUserMedia error:', error);
            }

            /**********************************************************
             *                 private methods
             **********************************************************/

            function clearRawData() {
                _buffers = [];
                _recLen = 0;
            }

            function mergeBuffers( buffers, len ) {
                var result = new Float32Array( len );
                var offset = 0;
                for( var i = 0; i < buffers.length; i++ ) {
                    var buffer = buffers[ i ];
                    result.set( buffer, offset );
                    offset += buffer.length;
                }
                return result;
            }

            /**********************************************************
             *          returned public API
             **********************************************************/

            return {
                startRecording: startRecording,
                stopRecording: stopRecording,
                getRawData: getRawData,
                hasRawData: hasRawData,
                onAudioRemoved: onAudioRemoved,
                finalize: finalize,
                getSampleRate: getSampleRate,
                initDeferred: _initDeferred
            };
        }

        return WebRTCRecorder;
});

define(
    'timer',[],
    function() {
        var Timer =  {
            start: function( length, resolution, onInterval, onComplete ) {
                var steps = (length / 100) * (resolution / 10);
                var speed = length / steps;
                var count = 0;
                var start = new Date().getTime();
                function interval()
                {
                    if ( count++ == steps ) {
                        onComplete(steps, count);
                    }
                    else {
                        var diff = (new Date().getTime() - start) - (count * speed);
                        var timeoutId = window.setTimeout(interval, (speed - diff));
                        onInterval( steps, count, timeoutId);
                    }
                }
                return window.setTimeout(interval, speed);
            },

            stop: function( timeoutId ) {
                window.clearTimeout( timeoutId );
            }
        };

        return Timer;
});

/** @license base64.js 2012 - imaya [ https://github.com/imaya/base64.js ] The MIT License */
(function() {'use strict';function i(e){var f=e.length,b="",c=i.a,d=0,a,g,h;if(1<f)for(;d<f-2;){a=e.charCodeAt(d);g=e.charCodeAt(d+1);h=e.charCodeAt(d+2);d+=3;if(255<a||255<g||255<h)throw Error("INVALID_CHARACTER_ERR");b+=c[a>>2&63]+c[g>>4&15|a<<4&63]+c[h>>6&3|g<<2&63]+c[h&63]}if(d<f){a=e.charCodeAt(d++);if(255<a)throw Error("INVALID_CHARACTER_ERR");b+=c[a>>2&63];if(d<f){g=e.charCodeAt(d);if(255<g)throw Error("INVALID_CHARACTER_ERR");b+=c[g>>4&15|a<<4&63]+c[g<<2&63]}else b+=c[a<<4&63]}a=4*((f+2)/3|0)-b.length;
0<a&&(b+=2===a?"==":"=");return b}i.a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");function k(e){for(var f=0,b=0,c=e.length,d="",a=0,g=k.b,h=k.c,q,j;"="===e.charAt(c-1);)--c;if(1===c%4||0<e.length&&0===c)throw Error("INVALID_CHARACTER_ERR");for(;b<c;){j=e.charCodeAt(b++);q=256>j?h[j]:-1;if(-1===q)throw Error("INVALID_CHARACTER_ERR");f=(f<<6)+q;a+=6;8<=a&&(a-=8,j=f>>a,d+=g[j],f^=j<<a)}return d}var l=k,m=Array(256),n;for(n=0;255>n;++n)m[n]=String.fromCharCode(n);
l.b=m;var p=k,r=i.a,s=new ("undefined"!==typeof Int16Array?Int16Array:Array)(256),t=k.b,u;for(u=0;255>u;++u)s[u]=r.indexOf(t[u]);p.c=s;var v=new ("undefined"!==typeof Uint8Array?Uint8Array:Array)(64),w,x;w=0;for(x=v.length;w<x;++w)v[w]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(w);new ("undefined"!==typeof Int16Array?Int16Array:Array)(256);var y;v instanceof Array||Array.prototype.slice.call(v);for(y=0;255>y;++y);void 0===this.atob&&(this.atob=k);void 0===this.btoa&&(this.btoa=i);}).call(this);

define("../../libs/base64_polyfill.min", function(){});

/*
 Copyright (c) 2010, Linden Research, Inc.
 Copyright (c) 2014, Joshua Bell

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 $/LicenseInfo$
 */

// Original can be found at:
//   https://bitbucket.org/lindenlab/llsd
// Modifications by Joshua Bell inexorabletash@gmail.com
//   https://github.com/inexorabletash/polyfill

// ES3/ES5 implementation of the Krhonos Typed Array Specification
//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/
//   Date: 2011-02-01
//
// Variations:
//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])
//  * Gradually migrating structure from Khronos spec to ES6 spec
(function(global) {
  'use strict';
  var undefined = (void 0); // Paranoia

  // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
  // create, and consume so much memory, that the browser appears frozen.
  var MAX_ARRAY_LENGTH = 1e5;

  // Approximations of internal ECMAScript conversion functions
  function Type(v) {
    switch(typeof v) {
    case 'undefined': return 'undefined';
    case 'boolean': return 'boolean';
    case 'number': return 'number';
    case 'string': return 'string';
    default: return v === null ? 'null' : 'object';
    }
  }

  // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
  function Class(v) { return Object.prototype.toString.call(v).replace(/^\[object *|\]$/g, ''); }
  function IsCallable(o) { return typeof o === 'function'; }
  function ToObject(v) {
    if (v === null || v === undefined) throw TypeError();
    return Object(v);
  }
  function ToInt32(v) { return v >> 0; }
  function ToUint32(v) { return v >>> 0; }

  // Snapshot intrinsics
  var LN2 = Math.LN2,
      abs = Math.abs,
      floor = Math.floor,
      log = Math.log,
      max = Math.max,
      min = Math.min,
      pow = Math.pow,
      round = Math.round;

  // emulate ES5 getter/setter API using legacy APIs
  // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
  // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
  // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)

  (function() {
    var orig = Object.defineProperty;
    var dom_only = !(function(){try{return Object.defineProperty({},'x',{});}catch(_){return false;}}());

    if (!orig || dom_only) {
      Object.defineProperty = function (o, prop, desc) {
        // In IE8 try built-in implementation for defining properties on DOM prototypes.
        if (orig)
          try { return orig(o, prop, desc); } catch (_) {}
        if (o !== Object(o))
          throw TypeError('Object.defineProperty called on non-object');
        if (Object.prototype.__defineGetter__ && ('get' in desc))
          Object.prototype.__defineGetter__.call(o, prop, desc.get);
        if (Object.prototype.__defineSetter__ && ('set' in desc))
          Object.prototype.__defineSetter__.call(o, prop, desc.set);
        if ('value' in desc)
          o[prop] = desc.value;
        return o;
      };
    }
  }());

  // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
  // for index in 0 ... obj.length
  function makeArrayAccessors(obj) {
    if (obj.length > MAX_ARRAY_LENGTH) throw RangeError('Array too large for polyfill');

    function makeArrayAccessor(index) {
      Object.defineProperty(obj, index, {
        'get': function() { return obj._getter(index); },
        'set': function(v) { obj._setter(index, v); },
        enumerable: true,
        configurable: false
      });
    }

    var i;
    for (i = 0; i < obj.length; i += 1) {
      makeArrayAccessor(i);
    }
  }

  // Internal conversion functions:
  //    pack<Type>()   - take a number (interpreted as Type), output a byte array
  //    unpack<Type>() - take a byte array, output a Type-like number

  function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
  function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

  function packI8(n) { return [n & 0xff]; }
  function unpackI8(bytes) { return as_signed(bytes[0], 8); }

  function packU8(n) { return [n & 0xff]; }
  function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

  function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

  function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
  function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

  function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
  function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

  function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
  function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

  function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
  function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

  function packIEEE754(v, ebits, fbits) {

    var bias = (1 << (ebits - 1)) - 1,
        s, e, f, ln,
        i, bits, str, bytes;

    function roundToEven(n) {
      var w = floor(n), f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }

    // Compute sign, exponent, fraction
    if (v !== v) {
      // NaN
      // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
      e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);

      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          // Overflow
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          // Normalized
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        // Denormalized
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }

    // Pack sign, exponent, fraction
    bits = [];
    for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
    for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');

    // Bits to bytes
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }

  function unpackIEEE754(bytes, ebits, fbits) {
    // Bytes to bits
    var bits = [], i, j, b, str,
        bias, s, e, f;

    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0); b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');

    // Unpack sign, exponent, fraction
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);

    // Produce number
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      // Normalized
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      // Denormalized
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }

  function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
  function packF64(v) { return packIEEE754(v, 11, 52); }
  function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
  function packF32(v) { return packIEEE754(v, 8, 23); }

  //
  // 3 The ArrayBuffer Type
  //

  (function() {

    function ArrayBuffer(length) {
      length = ToInt32(length);
      if (length < 0) throw RangeError('ArrayBuffer size is not a small enough positive integer.');
      Object.defineProperty(this, 'byteLength', {value: length});
      Object.defineProperty(this, '_bytes', {value: Array(length)});

      for (var i = 0; i < length; i += 1)
        this._bytes[i] = 0;
    }

    global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;

    //
    // 5 The Typed Array View Types
    //

    function $TypedArray$() {

      // %TypedArray% ( length )
      if (!arguments.length || typeof arguments[0] !== 'object') {
        return (function(length) {
          length = ToInt32(length);
          if (length < 0) throw RangeError('length is not a small enough positive integer.');
          Object.defineProperty(this, 'length', {value: length});
          Object.defineProperty(this, 'byteLength', {value: length * this.BYTES_PER_ELEMENT});
          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(this.byteLength)});
          Object.defineProperty(this, 'byteOffset', {value: 0});

         }).apply(this, arguments);
      }

      // %TypedArray% ( typedArray )
      if (arguments.length >= 1 &&
          Type(arguments[0]) === 'object' &&
          arguments[0] instanceof $TypedArray$) {
        return (function(typedArray){
          if (this.constructor !== typedArray.constructor) throw TypeError();

          var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;
          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});
          Object.defineProperty(this, 'byteLength', {value: byteLength});
          Object.defineProperty(this, 'byteOffset', {value: 0});
          Object.defineProperty(this, 'length', {value: typedArray.length});

          for (var i = 0; i < this.length; i += 1)
            this._setter(i, typedArray._getter(i));

        }).apply(this, arguments);
      }

      // %TypedArray% ( array )
      if (arguments.length >= 1 &&
          Type(arguments[0]) === 'object' &&
          !(arguments[0] instanceof $TypedArray$) &&
          !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {
        return (function(array) {

          var byteLength = array.length * this.BYTES_PER_ELEMENT;
          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});
          Object.defineProperty(this, 'byteLength', {value: byteLength});
          Object.defineProperty(this, 'byteOffset', {value: 0});
          Object.defineProperty(this, 'length', {value: array.length});

          for (var i = 0; i < this.length; i += 1) {
            var s = array[i];
            this._setter(i, Number(s));
          }
        }).apply(this, arguments);
      }

      // %TypedArray% ( buffer, byteOffset=0, length=undefined )
      if (arguments.length >= 1 &&
          Type(arguments[0]) === 'object' &&
          (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {
        return (function(buffer, byteOffset, length) {

          byteOffset = ToUint32(byteOffset);
          if (byteOffset > buffer.byteLength)
            throw RangeError('byteOffset out of range');

          // The given byteOffset must be a multiple of the element
          // size of the specific type, otherwise an exception is raised.
          if (byteOffset % this.BYTES_PER_ELEMENT)
            throw RangeError('buffer length minus the byteOffset is not a multiple of the element size.');

          if (length === undefined) {
            var byteLength = buffer.byteLength - byteOffset;
            if (byteLength % this.BYTES_PER_ELEMENT)
              throw RangeError('length of buffer minus byteOffset not a multiple of the element size');
            length = byteLength / this.BYTES_PER_ELEMENT;

          } else {
            length = ToUint32(length);
            byteLength = length * this.BYTES_PER_ELEMENT;
          }

          if ((byteOffset + byteLength) > buffer.byteLength)
            throw RangeError('byteOffset and length reference an area beyond the end of the buffer');

          Object.defineProperty(this, 'buffer', {value: buffer});
          Object.defineProperty(this, 'byteLength', {value: byteLength});
          Object.defineProperty(this, 'byteOffset', {value: byteOffset});
          Object.defineProperty(this, 'length', {value: length});

        }).apply(this, arguments);
      }

      // %TypedArray% ( all other argument combinations )
      throw TypeError();
    }

    // Properties of the %TypedArray Instrinsic Object

    // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )
    Object.defineProperty($TypedArray$, 'from', {value: function(iterable) {
      return new this(iterable);
    }});

    // %TypedArray%.of ( ...items )
    Object.defineProperty($TypedArray$, 'of', {value: function(/*...items*/) {
      return new this(arguments);
    }});

    // %TypedArray%.prototype
    var $TypedArrayPrototype$ = {};
    $TypedArray$.prototype = $TypedArrayPrototype$;

    // WebIDL: getter type (unsigned long index);
    Object.defineProperty($TypedArray$.prototype, '_getter', {value: function(index) {
      if (arguments.length < 1) throw SyntaxError('Not enough arguments');

      index = ToUint32(index);
      if (index >= this.length)
        return undefined;

      var bytes = [], i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        bytes.push(this.buffer._bytes[o]);
      }
      return this._unpack(bytes);
    }});

    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
    Object.defineProperty($TypedArray$.prototype, 'get', {value: $TypedArray$.prototype._getter});

    // WebIDL: setter void (unsigned long index, type value);
    Object.defineProperty($TypedArray$.prototype, '_setter', {value: function(index, value) {
      if (arguments.length < 2) throw SyntaxError('Not enough arguments');

      index = ToUint32(index);
      if (index >= this.length)
        return;

      var bytes = this._pack(value), i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        this.buffer._bytes[o] = bytes[i];
      }
    }});

    // get %TypedArray%.prototype.buffer
    // get %TypedArray%.prototype.byteLength
    // get %TypedArray%.prototype.byteOffset
    // -- applied directly to the object in the constructor

    // %TypedArray%.prototype.constructor
    Object.defineProperty($TypedArray$.prototype, 'constructor', {value: $TypedArray$});

    // %TypedArray%.prototype.copyWithin (target, start, end = this.length )
    Object.defineProperty($TypedArray$.prototype, 'copyWithin', {value: function(target, start) {
      var end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToUint32(lenVal);
      len = max(len, 0);
      var relativeTarget = ToInt32(target);
      var to;
      if (relativeTarget < 0)
        to = max(len + relativeTarget, 0);
      else
        to = min(relativeTarget, len);
      var relativeStart = ToInt32(start);
      var from;
      if (relativeStart < 0)
        from = max(len + relativeStart, 0);
      else
        from = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInt32(end);
      var final;
      if (relativeEnd < 0)
        final = max(len + relativeEnd, 0);
      else
        final = min(relativeEnd, len);
      var count = min(final - from, len - to);
      var direction;
      if (from < to && to < from + count) {
        direction = -1;
        from = from + count - 1;
        to = to + count - 1;
      } else {
        direction = 1;
      }
      while (count > 0) {
        o._setter(to, o._getter(from));
        from = from + direction;
        to = to + direction;
        count = count - 1;
      }
      return o;
    }});

    // %TypedArray%.prototype.entries ( )
    // -- defined in es6.js to shim browsers w/ native TypedArrays

    // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'every', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      var thisArg = arguments[1];
      for (var i = 0; i < len; i++) {
        if (!callbackfn.call(thisArg, t._getter(i), i, t))
          return false;
      }
      return true;
    }});

    // %TypedArray%.prototype.fill (value, start = 0, end = this.length )
    Object.defineProperty($TypedArray$.prototype, 'fill', {value: function(value) {
      var start = arguments[1],
          end = arguments[2];

      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToUint32(lenVal);
      len = max(len, 0);
      var relativeStart = ToInt32(start);
      var k;
      if (relativeStart < 0)
        k = max((len + relativeStart), 0);
      else
        k = min(relativeStart, len);
      var relativeEnd;
      if (end === undefined)
        relativeEnd = len;
      else
        relativeEnd = ToInt32(end);
      var final;
      if (relativeEnd < 0)
        final = max((len + relativeEnd), 0);
      else
        final = min(relativeEnd, len);
      while (k < final) {
        o._setter(k, value);
        k += 1;
      }
      return o;
    }});

    // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'filter', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      var res = [];
      var thisp = arguments[1];
      for (var i = 0; i < len; i++) {
        var val = t._getter(i); // in case fun mutates this
        if (callbackfn.call(thisp, val, i, t))
          res.push(val);
      }
      return new this.constructor(res);
    }});

    // %TypedArray%.prototype.find (predicate, thisArg = undefined)
    Object.defineProperty($TypedArray$.prototype, 'find', {value: function(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToUint32(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var kValue = o._getter(k);
        var testResult = predicate.call(t, kValue, k, o);
        if (Boolean(testResult))
          return kValue;
        ++k;
      }
      return undefined;
    }});

    // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'findIndex', {value: function(predicate) {
      var o = ToObject(this);
      var lenValue = o.length;
      var len = ToUint32(lenValue);
      if (!IsCallable(predicate)) throw TypeError();
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var k = 0;
      while (k < len) {
        var kValue = o._getter(k);
        var testResult = predicate.call(t, kValue, k, o);
        if (Boolean(testResult))
          return k;
        ++k;
      }
      return -1;
    }});

    // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'forEach', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      var thisp = arguments[1];
      for (var i = 0; i < len; i++)
        callbackfn.call(thisp, t._getter(i), i, t);
    }});

    // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )
    Object.defineProperty($TypedArray$.prototype, 'indexOf', {value: function(searchElement) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (len === 0) return -1;
      var n = 0;
      if (arguments.length > 0) {
        n = Number(arguments[1]);
        if (n !== n) {
          n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
          n = (n > 0 || -1) * floor(abs(n));
        }
      }
      if (n >= len) return -1;
      var k = n >= 0 ? n : max(len - abs(n), 0);
      for (; k < len; k++) {
        if (t._getter(k) === searchElement) {
          return k;
        }
      }
      return -1;
    }});

    // %TypedArray%.prototype.join ( separator )
    Object.defineProperty($TypedArray$.prototype, 'join', {value: function(separator) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      var tmp = Array(len);
      for (var i = 0; i < len; ++i)
        tmp[i] = t._getter(i);
      return tmp.join(separator === undefined ? ',' : separator); // Hack for IE7
    }});

    // %TypedArray%.prototype.keys ( )
    // -- defined in es6.js to shim browsers w/ native TypedArrays

    // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )
    Object.defineProperty($TypedArray$.prototype, 'lastIndexOf', {value: function(searchElement) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (len === 0) return -1;
      var n = len;
      if (arguments.length > 1) {
        n = Number(arguments[1]);
        if (n !== n) {
          n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
          n = (n > 0 || -1) * floor(abs(n));
        }
      }
      var k = n >= 0 ? min(n, len - 1) : len - abs(n);
      for (; k >= 0; k--) {
        if (t._getter(k) === searchElement)
          return k;
      }
      return -1;
    }});

    // get %TypedArray%.prototype.length
    // -- applied directly to the object in the constructor

    // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'map', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      var res = []; res.length = len;
      var thisp = arguments[1];
      for (var i = 0; i < len; i++)
        res[i] = callbackfn.call(thisp, t._getter(i), i, t);
      return new this.constructor(res);
    }});

    // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )
    Object.defineProperty($TypedArray$.prototype, 'reduce', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      // no value to return if no initial value and an empty array
      if (len === 0 && arguments.length === 1) throw TypeError();
      var k = 0;
      var accumulator;
      if (arguments.length >= 2) {
        accumulator = arguments[1];
      } else {
        accumulator = t._getter(k++);
      }
      while (k < len) {
        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);
        k++;
      }
      return accumulator;
    }});

    // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )
    Object.defineProperty($TypedArray$.prototype, 'reduceRight', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      // no value to return if no initial value, empty array
      if (len === 0 && arguments.length === 1) throw TypeError();
      var k = len - 1;
      var accumulator;
      if (arguments.length >= 2) {
        accumulator = arguments[1];
      } else {
        accumulator = t._getter(k--);
      }
      while (k >= 0) {
        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);
        k--;
      }
      return accumulator;
    }});

    // %TypedArray%.prototype.reverse ( )
    Object.defineProperty($TypedArray$.prototype, 'reverse', {value: function() {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      var half = floor(len / 2);
      for (var i = 0, j = len - 1; i < half; ++i, --j) {
        var tmp = t._getter(i);
        t._setter(i, t._getter(j));
        t._setter(j, tmp);
      }
      return t;
    }});

    // %TypedArray%.prototype.set(array, offset = 0 )
    // %TypedArray%.prototype.set(typedArray, offset = 0 )
    // WebIDL: void set(TypedArray array, optional unsigned long offset);
    // WebIDL: void set(sequence<type> array, optional unsigned long offset);
    Object.defineProperty($TypedArray$.prototype, 'set', {value: function(index, value) {
      if (arguments.length < 1) throw SyntaxError('Not enough arguments');
      var array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
        // void set(TypedArray array, optional unsigned long offset);
        array = arguments[0];
        offset = ToUint32(arguments[1]);

        if (offset + array.length > this.length) {
          throw RangeError('Offset plus length of array is out of range');
        }

        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
        byteLength = array.length * this.BYTES_PER_ELEMENT;

        if (array.buffer === this.buffer) {
          tmp = [];
          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
            tmp[i] = array.buffer._bytes[s];
          }
          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
            this.buffer._bytes[d] = tmp[i];
          }
        } else {
          for (i = 0, s = array.byteOffset, d = byteOffset;
               i < byteLength; i += 1, s += 1, d += 1) {
            this.buffer._bytes[d] = array.buffer._bytes[s];
          }
        }
      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
        // void set(sequence<type> array, optional unsigned long offset);
        sequence = arguments[0];
        len = ToUint32(sequence.length);
        offset = ToUint32(arguments[1]);

        if (offset + len > this.length) {
          throw RangeError('Offset plus length of array is out of range');
        }

        for (i = 0; i < len; i += 1) {
          s = sequence[i];
          this._setter(offset + i, Number(s));
        }
      } else {
        throw TypeError('Unexpected argument type(s)');
      }
    }});

    // %TypedArray%.prototype.slice ( start, end )
    Object.defineProperty($TypedArray$.prototype, 'slice', {value: function(start, end) {
      var o = ToObject(this);
      var lenVal = o.length;
      var len = ToUint32(lenVal);
      var relativeStart = ToInt32(start);
      var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);
      var relativeEnd = (end === undefined) ? len : ToInt32(end);
      var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);
      var count = final - k;
      var c = o.constructor;
      var a = new c(count);
      var n = 0;
      while (k < final) {
        var kValue = o._getter(k);
        a._setter(n, kValue);
        ++k;
        ++n;
      }
      return a;
    }});

    // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )
    Object.defineProperty($TypedArray$.prototype, 'some', {value: function(callbackfn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      if (!IsCallable(callbackfn)) throw TypeError();
      var thisp = arguments[1];
      for (var i = 0; i < len; i++) {
        if (callbackfn.call(thisp, t._getter(i), i, t)) {
          return true;
        }
      }
      return false;
    }});

    // %TypedArray%.prototype.sort ( comparefn )
    Object.defineProperty($TypedArray$.prototype, 'sort', {value: function(comparefn) {
      if (this === undefined || this === null) throw TypeError();
      var t = Object(this);
      var len = ToUint32(t.length);
      var tmp = Array(len);
      for (var i = 0; i < len; ++i)
        tmp[i] = t._getter(i);
      if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9
      for (i = 0; i < len; ++i)
        t._setter(i, tmp[i]);
      return t;
    }});

    // %TypedArray%.prototype.subarray(begin = 0, end = this.length )
    // WebIDL: TypedArray subarray(long begin, optional long end);
    Object.defineProperty($TypedArray$.prototype, 'subarray', {value: function(start, end) {
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

      start = ToInt32(start);
      end = ToInt32(end);

      if (arguments.length < 1) { start = 0; }
      if (arguments.length < 2) { end = this.length; }

      if (start < 0) { start = this.length + start; }
      if (end < 0) { end = this.length + end; }

      start = clamp(start, 0, this.length);
      end = clamp(end, 0, this.length);

      var len = end - start;
      if (len < 0) {
        len = 0;
      }

      return new this.constructor(
        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
    }});

    // %TypedArray%.prototype.toLocaleString ( )
    // %TypedArray%.prototype.toString ( )
    // %TypedArray%.prototype.values ( )
    // %TypedArray%.prototype [ @@iterator ] ( )
    // get %TypedArray%.prototype [ @@toStringTag ]
    // -- defined in es6.js to shim browsers w/ native TypedArrays

    function makeTypedArray(elementSize, pack, unpack) {
      // Each TypedArray type requires a distinct constructor instance with
      // identical logic, which this produces.
      var TypedArray = function() {
        Object.defineProperty(this, 'constructor', {value: TypedArray});
        $TypedArray$.apply(this, arguments);
        makeArrayAccessors(this);
      };
      if ('__proto__' in TypedArray) {
        TypedArray.__proto__ = $TypedArray$;
      } else {
        TypedArray.from = $TypedArray$.from;
        TypedArray.of = $TypedArray$.of;
      }

      TypedArray.BYTES_PER_ELEMENT = elementSize;

      var TypedArrayPrototype = function() {};
      TypedArrayPrototype.prototype = $TypedArrayPrototype$;

      TypedArray.prototype = new TypedArrayPrototype();

      Object.defineProperty(TypedArray.prototype, 'BYTES_PER_ELEMENT', {value: elementSize});
      Object.defineProperty(TypedArray.prototype, '_pack', {value: pack});
      Object.defineProperty(TypedArray.prototype, '_unpack', {value: unpack});

      return TypedArray;
    }

    var Int8Array = makeTypedArray(1, packI8, unpackI8);
    var Uint8Array = makeTypedArray(1, packU8, unpackU8);
    var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);
    var Int16Array = makeTypedArray(2, packI16, unpackI16);
    var Uint16Array = makeTypedArray(2, packU16, unpackU16);
    var Int32Array = makeTypedArray(4, packI32, unpackI32);
    var Uint32Array = makeTypedArray(4, packU32, unpackU32);
    var Float32Array = makeTypedArray(4, packF32, unpackF32);
    var Float64Array = makeTypedArray(8, packF64, unpackF64);

    global.Int8Array = global.Int8Array || Int8Array;
    global.Uint8Array = global.Uint8Array || Uint8Array;
    global.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;
    global.Int16Array = global.Int16Array || Int16Array;
    global.Uint16Array = global.Uint16Array || Uint16Array;
    global.Int32Array = global.Int32Array || Int32Array;
    global.Uint32Array = global.Uint32Array || Uint32Array;
    global.Float32Array = global.Float32Array || Float32Array;
    global.Float64Array = global.Float64Array || Float64Array;
  }());

  //
  // 6 The DataView View Type
  //

  (function() {
    function r(array, index) {
      return IsCallable(array.get) ? array.get(index) : array[index];
    }

    var IS_BIG_ENDIAN = (function() {
      var u16array = new Uint16Array([0x1234]),
          u8array = new Uint8Array(u16array.buffer);
      return r(u8array, 0) === 0x12;
    }());

    // DataView(buffer, byteOffset=0, byteLength=undefined)
    // WebIDL: Constructor(ArrayBuffer buffer,
    //                     optional unsigned long byteOffset,
    //                     optional unsigned long byteLength)
    function DataView(buffer, byteOffset, byteLength) {
      if (!(buffer instanceof ArrayBuffer || Class(buffer) === 'ArrayBuffer')) throw TypeError();

      byteOffset = ToUint32(byteOffset);
      if (byteOffset > buffer.byteLength)
        throw RangeError('byteOffset out of range');

      if (byteLength === undefined)
        byteLength = buffer.byteLength - byteOffset;
      else
        byteLength = ToUint32(byteLength);

      if ((byteOffset + byteLength) > buffer.byteLength)
        throw RangeError('byteOffset and length reference an area beyond the end of the buffer');

      Object.defineProperty(this, 'buffer', {value: buffer});
      Object.defineProperty(this, 'byteLength', {value: byteLength});
      Object.defineProperty(this, 'byteOffset', {value: byteOffset});
    };

    // get DataView.prototype.buffer
    // get DataView.prototype.byteLength
    // get DataView.prototype.byteOffset
    // -- applied directly to instances by the constructor

    function makeGetter(arrayType) {
      return function GetViewValue(byteOffset, littleEndian) {
        byteOffset = ToUint32(byteOffset);

        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
          throw RangeError('Array index out of range');

        byteOffset += this.byteOffset;

        var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
            bytes = [];
        for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
          bytes.push(r(uint8Array, i));

        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))
          bytes.reverse();

        return r(new arrayType(new Uint8Array(bytes).buffer), 0);
      };
    }

    Object.defineProperty(DataView.prototype, 'getUint8', {value: makeGetter(Uint8Array)});
    Object.defineProperty(DataView.prototype, 'getInt8', {value: makeGetter(Int8Array)});
    Object.defineProperty(DataView.prototype, 'getUint16', {value: makeGetter(Uint16Array)});
    Object.defineProperty(DataView.prototype, 'getInt16', {value: makeGetter(Int16Array)});
    Object.defineProperty(DataView.prototype, 'getUint32', {value: makeGetter(Uint32Array)});
    Object.defineProperty(DataView.prototype, 'getInt32', {value: makeGetter(Int32Array)});
    Object.defineProperty(DataView.prototype, 'getFloat32', {value: makeGetter(Float32Array)});
    Object.defineProperty(DataView.prototype, 'getFloat64', {value: makeGetter(Float64Array)});

    function makeSetter(arrayType) {
      return function SetViewValue(byteOffset, value, littleEndian) {
        byteOffset = ToUint32(byteOffset);
        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
          throw RangeError('Array index out of range');

        // Get bytes
        var typeArray = new arrayType([value]),
            byteArray = new Uint8Array(typeArray.buffer),
            bytes = [], i, byteView;

        for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
          bytes.push(r(byteArray, i));

        // Flip if necessary
        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))
          bytes.reverse();

        // Write them
        byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
        byteView.set(bytes);
      };
    }

    Object.defineProperty(DataView.prototype, 'setUint8', {value: makeSetter(Uint8Array)});
    Object.defineProperty(DataView.prototype, 'setInt8', {value: makeSetter(Int8Array)});
    Object.defineProperty(DataView.prototype, 'setUint16', {value: makeSetter(Uint16Array)});
    Object.defineProperty(DataView.prototype, 'setInt16', {value: makeSetter(Int16Array)});
    Object.defineProperty(DataView.prototype, 'setUint32', {value: makeSetter(Uint32Array)});
    Object.defineProperty(DataView.prototype, 'setInt32', {value: makeSetter(Int32Array)});
    Object.defineProperty(DataView.prototype, 'setFloat32', {value: makeSetter(Float32Array)});
    Object.defineProperty(DataView.prototype, 'setFloat64', {value: makeSetter(Float64Array)});

    global.DataView = global.DataView || DataView;

  }());

}(this));
define("../../libs/typedarray", function(){});

/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function(uri) {
				var
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
				;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				builder.append(blobParts[i]);
			}
		}
		return builder.getBlob(type);
	};
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
define("../../libs/Blob", function(){});

/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
define("../../libs/swfobject", function(){});

define(
	'flash-recorder',[
		'timer',
		'../../libs/base64_polyfill.min',
		'../../libs/typedarray',
		'../../libs/Blob',
		'../../libs/swfobject'
	],
	function( Timer ) {
		var FlashRecorder = function ( $container, config ) {

			var FLASH_URL = 'public/javascripts/recorder/audiorecorder.swf';//AudioRecordPlayback.swf';
			var _$flash;
			var _flash;
			var _flashDispatcher;
			var _prevState;
			var _state;
			var _timoutId = null;

			var _encoder;
			var _buffers;
            var _recLen;
            var _initDeferred;
            var _timeoutId;

			window.TN8 = window.TN8 || {};
			window.TN8.flashRecorder = window.TN8.flashRecorder || {
				types: {},
				event: function ( event ) {
					var listeners = this.types[ event.type ];
					if( listeners ) {
						for( var i = 0; i < listeners.length; i++ ) {
							listeners[ i ]( event );
						}
					}
				},
				addEventListener: function( type, fn ) {
					if( !this.types[ type ] ) {
						this.types[ type ] = [];
					}
					this.types[ type ].push( fn );
				},

				removeEventListener: function( type, fn ) {
					if( this.types[ type ] ) {
						var fnIndex = this.types[ type ].indexOf( fn );
						if( fnIndex >= 0 ) {
							this.types[ type ].splice( fnIndex, 1 );
						}
					}
				}
			};

			_initDeferred = $.Deferred();
			_flashDispatcher = window.TN8.flashRecorder;

			_flashDispatcher.addEventListener( 'flashReady', onFlashReady);
			_flashDispatcher.addEventListener( 'setState', setState);
			_flashDispatcher.addEventListener( 'micAccessAllowed', onMicAccessAllowed);
			_flashDispatcher.addEventListener( 'micActivityStarted', onMicActivityStarted);
			//_flashDispatcher.addEventListener( 'micSampleData', onMicSampleData);
			_flashDispatcher.addEventListener( 'audioInput', onAudioInput);

			embedSWF();

			/**********************************************************
             *                 public API methods
             **********************************************************/

            function setDataForPlayback( float32Array ) {
            	var arrayForFlash = Array.prototype.slice.call( float32Array );
            	var duration = _flash.setDataForPlayback( arrayForFlash );
            	//console.log('Flash recording duration:',duration);
            }

			function startRecording() {
				// for flash, first we must get mic access
				var accessAllowed = _flash.isAccessAllowed();
				var accessDenied = _flash.isAccessDenied();
				var hasMic = _flash.hasMic();

				// console.log('FlashRecorder > startRecording, accessAllowed:',accessAllowed,', accessDenied:',accessDenied,', hasMic:',hasMic );

				if ( hasMic ) {
					if ( accessAllowed) {
						record();
					} else {
						_flash.askPermissionForMicAccess();
					}
				} else {
					_flash.getMic();
				}
			}

			function stopRecording() {
				// console.log('FlashRecorder > stopRecording, _timeoutId:',_timeoutId);
				//_flashDispatcher.removeEventListener( 'onFlashAudioInput', onFlashAudioInput );
				if ( _timeoutId !== null ) {
					Timer.stop( _timeoutId );
					_timeoutId = null;
				}
				setState( {state: 'stop', recorderId: config.recorderId } );
			}

            function getRawData( unmerged ) {
                //console.log('Flash Recorder > getRawData, unmerged:',unmerged);
                if ( unmerged ) {
                	return _buffers;
                } else {
                	return mergeBuffers( _buffers, _recLen );
                }
            }

            function hasRawData() {
				return  typeof _buffers !== 'undefined' && Object.prototype.toString.call(_buffers) === '[object Array]' && _buffers.length > 0 && _recLen > 0;
                //return  'typeof _buffers !== undefined' && _buffers.length > 0 && _recLen > 0;
            }

            function onAudioRemoved() {
                clearRawData();
            }

			function finalize() {
				if ( _flashDispatcher ) {
					_flashDispatcher.removeEventListener( 'flashReady', onFlashReady);
					_flashDispatcher.removeEventListener( 'setState', setState);
					_flashDispatcher.removeEventListener( 'micAccessAllowed', onMicAccessAllowed);
					_flashDispatcher.removeEventListener( 'micActivityStarted', onMicActivityStarted);
					//_flashDispatcher.removeEventListener( 'micSampleData', onMicSampleData);
					_flashDispatcher.removeEventListener( 'audioInput', onAudioInput);
				}
				$flash = null;
				_flash = null;
				_flashDispatcher = null;
				_initDeferred = null;
			}

			function getSampleRate() {
				return _flash.getSampleRate();
			}
			/**********************************************************
             *                timer interval/complete callbacks
             **********************************************************/

            function onTimerInterval(totalSteps, currentStep, timeoutId) {
            	//console.log('Flash Recorder > onTimerInterval, totalSteps:',totalSteps,', currentStep:',currentStep,', timeoutId:',timeoutId);
            	_timeoutId = timeoutId;
            	onMicSampleData( { level:_flash.getMicLevel(), recorderId: config.recorderId} );
            }

            function onTimerComplete(totalSteps, currentStep) {
            	_timeoutId = null;
            }

			/**********************************************************
             *                swf 'event' handlers/callbacks
             **********************************************************/

            // mic access allowed
			function onMicAccessAllowed( data ) {
				if ( config.recorderId !== data.recorderId ) { return; }

				// console.log('FlashRecorder > onMicAccessAllowed, data:',data);
				record();
				//$container.trigger( 'audioenabled' );
				//$container.trigger( 'flashRecordingStarted' );
			}

			// mic activity started
			function onMicActivityStarted( data ) {
				if ( config.recorderId !== data.recorderId ) { return; }

				// trigger event that audio stream has begun for recording
				$container.trigger( 'audioenabled' );
				// start timer for monitoring mic level with input meter
				_timeoutId = Timer.start( config.totalRecordingTime, 20, onTimerInterval, onTimerComplete );
			}

			// mic sample data activity
			function onMicSampleData( data ) {
				if ( config.recorderId !== data.recorderId ) { return; }

				//console.log('FlashRecorder > onMicSampleData, data.level:',data.level);
				$container.trigger( 'micSampleData', data.level );
			}

			// mic sample data activity with full snapshot buffer
			// like webrtc onaudioprocess
			function onAudioInput( data ) {
				if ( config.recorderId !== data.recorderId ) { return; }

				//console.log('flashRecorder > onAudioInput, data:',data)
				var buffer = new Float32Array( data.data );
				//console.log('FlashRecorder > onAudioInput > buffer.length:',buffer.length);
                _buffers.push( buffer );
                _recLen += 2048;
				$container.trigger( "audioinput", [ buffer] );
			}

			// swf init handler
			function onFlashReady( data ) {
				if ( config.recorderId !== data.recorderId ) { return; }

				//console.log('onFlashReady > config:',config);
				_flashDispatcher.removeEventListener( 'flashReady', onFlashReady);
				//_flash.setTimerParams( FLASH_FRAME_RATE );
				_flash.setMicParams({
					echoSuppression: true,
					rate: 44,
					gain: Math.min( 100, config.options.micGain + 35),
					silenceLevel: 0,
					silenceTimeout: config.totalRecordingTime/*,
					encodeQuality: config.spxQuality*/
				});

				_initDeferred.resolve( _flash );
			}

			// possible state values: 'init', 'denied', 'allowed', 'reset', 'permission', 'record', 'play', 'stop'
			function setState(data) {
				if ( config.recorderId !== data.recorderId || _state === data.state ) { return; }

				_prevState = _state;
				_state = data.state;

				//console.log('FlashRecorder > setState, _state:',_state);

				switch ( _state ) {
					case 'init':
					case 'denied':
					case 'allowed':
					case 'reset':
						toggleSecurity(false);
						// --- toggleIcon('record');
						// --- updateMarkerState(false);
						break;
					case 'permission':
						toggleSecurity(true);
						break;
					case 'record':
						toggleSecurity(false);
						_flash.setMicParams( {loopBack:true} );
						// --- updateMarkerState(false);
						break;
					case 'play':
						// --- toggleIcon('stop');
						// --- updateMarkerState(true);
						break;
					case 'stop':
						// --- toggleIcon('play');
						// --- updateMarkerState(false);
						if ( _prevState === 'record' || _prevState === 'play' ) {
							_flash.stopEither();
							_flash.setMicParams( {loopBack:false} );
						}
						break;
				}
			}

			/**********************************************************
             *     swf embedding/loading/initialization methods
             **********************************************************/

			function embedSWF() {
				var id = $container.attr( 'id' ) + '-swfobject';
				$('<div id="' + id + '"><p>Flash Audio Recorder</p></div>')
					.appendTo( $container );
				var flashVars = {
					id: id,
					recorderId: config.recorderId
				};
				var params = {
					allowscriptaccess: "always",
					wmode: "transparent"
				};
				var attributes = {
					id: id,
					name: id,
					"class" : "recorder-swf"
				};
				var width = '215'; //'430'
				var height = '138'; //'276'
				swfobject.embedSWF( getBaseURL() + FLASH_URL, id, width, height, "10.3", false, flashVars, params, attributes, onSWFLoad );
			}

			// swfobject load callback
			/*
			Properties of this event object are:
				success, Boolean to indicate whether the creation of a Flash plugin-in <object> DOM was successful or not
				id, String indicating the ID used in swfobject.registerObject
				ref, HTML object element reference (returns undefined when success=false)
			 */
			function onSWFLoad( e ) {
				// TODO - appropriate error handling
				if (!e.success) {
					console.error('Audio recorder > Flash plug-in <object> DOM creation failed');
				} else {
					_flash = e.ref;
					_$flash = $( _flash );
				}
			}

			/**********************************************************
             *                 private methods
             **********************************************************/

            function getBaseURL() {
                return config.baseURL; //(config.teiRepo ? config.baseURL : '');
            }

            function clearRawData() {
                _buffers = [];
                _recLen = 0;
            }

            function record() {
            	clearRawData();
            	_flash.record();
            }

            function mergeBuffers( buffers, len ) {
                var result = new Float32Array( len );
                var offset = 0;
                for( var i = 0; i < buffers.length; i++ ) {
                    var buffer = buffers[ i ];
                    result.set( buffer, offset );
                    offset += buffer.length;
                }
                return result;
            }

			function toggleSecurity( show ) {
				var fn = show ? _$flash.addClass : _$flash.removeClass;
				fn.call( _$flash, 'shown' );
			}

			/**********************************************************
             *          returned public API
             **********************************************************/

             return {
             	initDeferred: _initDeferred,
                startRecording: startRecording,
                stopRecording: stopRecording,
                setDataForPlayback: setDataForPlayback,
                getRawData: getRawData,
                hasRawData: hasRawData,
                onAudioRemoved: onAudioRemoved,
                finalize: finalize,
                getSampleRate: getSampleRate
            };
		};

		return FlashRecorder;
});
define(
	'ios-recorder',[],
	function() {
		function IosRecorder( $container, config ) {
			var _scope;
			var _media = null;
			var _status;
			var _file;
			var _fileEntry;
			var _hasAudio = false;
			var _isEncoding = false;
			var _id = uniqueId();
			var _recordFileName = _id + ".m4a";
			var _recordingCallback = null;
			var _recordingIntervalId = null;
			var _recordingIntervalDuration = 50; // in milliseconds

			//Status Constants (For native-recorder internal use only)
			var RECORDING = 1;
			var PLAYING = 2;
			var RECORDING_STOPPED = 3;
			var PLAYING_STOPPED = 4;

			//Event Constants
			var DATAURL_GENERATED = "dataurl_generated";

			// no waiting for initialization here
			_initDeferred = $.Deferred();
            _initDeferred.resolve();

			/**********************************************************
             *                 public API methods
             **********************************************************/

			function onAudioRemoved() {
				doLog('onAudioRemoved');
				deleteRecordedFile();
			}

			// step:1
			function startRecording() {
				doLog('startRecording');
				createMedia();
	        }

	        function stopRecording( deleteFile ) {
	            doLog('stopRecording\n\t_media:',_media,'\n\t_status:',_status,'\n\tdeleteFile:',deleteFile);
	            if ( _media !== null && _status == RECORDING ) {
	            	clearRecordingInterval();
	            	_status = RECORDING_STOPPED;
	                _media.stopRecord();
	                if ( !!deleteFile ) {
	                	deleteRecordedFile();
	                }
	            }
	        }
	        function setRecordingCallback( func ) {
	        	_recordingCallback = ( !!func && typeof func === 'function' ) ? func : null;
	        	doLog('setRecordingCallback, _recordingCallback:',_recordingCallback);
	        }

	        function deleteRecordedFile() {
	        	doLog('deleteRecordedFile, _fileEntry:',_fileEntry);
	        	var successCallback = function() {
	        		doLog('deleteRecordedFile > success callback\n\tFile:',_recordFileName,"deleted.");
            		_file = null;
            		_fileEntry = null;
            		_media = null;
	        	};
	        	var failureCallback = function() {
	        		doLog('deleteRecordedFile > failure callback\n\tFile:',_recordFileName,"not deleted.");
	        	};
	        	if( _fileEntry) {
	        		_fileEntry.remove( successCallback, failureCallback);
	        	}
	        }

	        function encodeM4AB64( ) {
	        	var defer = $.Deferred();
				generateDataURLAndGetB64(defer);
				return defer;
	        }

	        function hasRawData() {
	        	// return boolean representing if raw data for recording exists
	        	return _hasAudio && !_isEncoding ? true : false;
		    }

	        function getRawData() {
				// return an array with something in it
				// this represents that there is raw audio data
				// even though this is not that data
	        	return [1];
	        }

	        function getSampleRate() {
	        	// This is set on the native side. Not customizable.
	        	return 16000;
	        }

	        function finalize() {
	        	doLog('finalize');
	        	clearRecordingInterval();
				deleteRecordedFile();
				_recordingCallback = null;
				_file = null;
            	_fileEntry = null;
            	_media = null;
            }

            // ------------------------------------------------------------------------
            //                    encode media methods and callbacks
            // ------------------------------------------------------------------------

            function generateDataURLAndGetB64(defer) {
	        	// Do a momentary play() to get a playable dataURL. We stop the play as soon as it starts in onStatusChange Case 2 -_- This needs to be done
	        	_media.release();
	        	_isEncoding = true;
	        	play();

				var successCallback = function(file) {
					var reader = new FileReader();
		            reader.onloadend = function(e) {
		                var dataUrl = e.target.result;
		                var M4AB64 = dataUrl.slice(24, dataUrl.length);
		                _isEncoding = false;
		                defer.resolve(M4AB64);
		            };
		            reader.readAsDataURL(file);
				};
				var failureCallback = function(e) {
					console.log('Could not get a file instance');
				};

				_fileEntry.file( successCallback, failureCallback);
	        }

	        function play() {
	            _status = PLAYING;
                _media.play();
	        }

	        function stopPlaying() {
	        	if( _status == PLAYING ) {
	        		_status = PLAYING_STOPPED;
	        		_media.stop();
	        		_media = null;
	        		_hasAudio = false;
	        	}
	        }

            // ------------------------------------------------------------------------
            //                    create media methods and callbacks
            // ------------------------------------------------------------------------

            // step:2
            function createMedia() {
            	doLog('createMedia');
                window.requestFileSystem(LocalFileSystem.TEMPORARY, 0, requestFileSystemSuccess, requestFileSystemFailure);
	        }

	        // ------------- requestFileSystem callbacks ----------------

	        function requestFileSystemFailure(e) {
	        	doLog( 'requestFileSystemFailure > could not access file system, e:',JSON.stringify(e) );
	        }

	        // step:3
	        function requestFileSystemSuccess( fileSystem ) {
        		doLog('requestFileSystemSuccess, _recordFileName:',_recordFileName);
        		fileSystem.root.getFile( _recordFileName, {
                create: true,
                exclusive: true
            	}, getFileSuccess, getFileFailure);
	        }

	        // ------------- getFile callbacks ----------------

	        function getFileFailure( e ) {
	        	doLog('getFileFailure, _recordFileName:',_recordFileName,', e.code:',e.code);
	        }

	        // step:4
			function getFileSuccess(fileEntry) {
	        	doLog('getFileSuccess, _recordFileName:',_recordFileName,', fileEntry:',fileEntry);
	        	_fileEntry = fileEntry;
            	_media = new Media(fileEntry.fullPath, mediaSuccess, mediaFailure, onMediaStatusChange);
            	_hasAudio = true;
            	_status = RECORDING;
                _media.startRecord();
	        }

	        // ------------- create media callbacks ----------------

	        // Cordova's default callback for status change
	        function onMediaStatusChange() {
	        	var status = arguments[0];
	   			// The following are Cordova's status constants and are reported as the only parameter to the mediaStatus callback:
	        	var meaningfulStatus = {
	        		'0': 'Media.MEDIA_NONE (0)',
	        		'1': 'Media.MEDIA_STARTING (1)',
	        		'2': 'Media.MEDIA_RUNNING (2)',
	        		'3': 'Media.MEDIA_PAUSED (3)',
	        		'4': 'Media.MEDIA_STOPPED (4)'
	        	}[status];
	        	// this class' _status constants
	        	var meaningful_status = {
	        		'1': 'RECORDING (1)',
	        		'2': 'PLAYING (2)',
	        		'3': 'RECORDING_STOPPED (3)',
	        		'4': 'LAYING_STOPPED (4)'
	        	}[_status];
	        	doLog('onStatusChange, status:',meaningfulStatus,' _status:',meaningful_status);
				switch( status ) {
					case 2:
						// console.log('MEDIA_RUNNING');
						if ( _status === PLAYING ) {
							stopPlaying();
						} else if ( _status === RECORDING ) {
							clearRecordingInterval();
							_recordingIntervalId = window.setInterval( reportAmplitude, _recordingIntervalDuration );
						}
						break;
					case 4:
						// console.log('MEDIA_STOPPED');
						break;
					default:
						console.log("Cordova Unknown Error");
				}
	        }

	        function mediaFailure(error) {
	        	doLog('mediaFailure\n\tcode:',error.code,'\n\tmessage:',error.message);
	        }

	        function mediaSuccess() {
	        	doLog('mediaSuccess');
	        	// This is called when recording stopped and play stopped
	        }

	        function clearRecordingInterval() {
	        	doLog('clearRecordingInterval, !!_recordingIntervalId:',!!_recordingIntervalId,', _recordingIntervalId:',_recordingIntervalId);
	        	if ( !!_recordingIntervalId ) {
					window.clearInterval( _recordingIntervalId );
					_recordingIntervalId = null;
				}
	        }

	        function reportAmplitude() {
	        	// amplitude -160.0 to 0, where -80.0 is pragmatically silence
                // so really use -70 to 0;
	        	var minValue = -70;
                var successCallback = function ( amplitude ) {
	        		var amplitudePct = Math.abs( (Math.max(amplitude,minValue)-minValue)/-minValue );
	        		if ( !!_recordingCallback ) {
	        			_recordingCallback( amplitudePct );
	        		} else if ( $container && $container.length > 0 ) {
	        			$container.trigger( 'micSampleData', amplitudePct*100 );
	        		} else {
	        			doLog( 'reportAmplitude > successCallback (no _recordingCallback defined), amplitudePct:',amplitudePct );
	        		}
	        	};
	        	var failureCallback = function ( error ) {
	        		doLog( 'reportAmplitude > failureCallback, error:',error );
	        	};
	        	_testNavBridge.averageRecordingPower( successCallback, failureCallback );
	        }

	        // ------------------------------------------------------------------------
            //                                  utility methods
            // ------------------------------------------------------------------------

	        function uniqueId( id ) {
                var s = id;
                if ( typeof s !== 'string' || s.length <= 0 ) {
                    s = '';
                    var i, c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                    for ( i=0; i<8; i++ ) { s += c.charAt(Math.floor(Math.random() * (i === 0 ? c.length-10 : c.length) )); }
                }
                return s;
            }

	        function doLog() {
                var args = ['---- IosRecorder >'].concat( Array.prototype.slice.call(arguments) );
                console.log.apply( console, args);
            }

            /**********************************************************
             *          returned public API
             **********************************************************/

			return {
				initDeferred: _initDeferred,
				startRecording: startRecording,
                stopRecording: stopRecording,
                setRecordingCallback: setRecordingCallback,
                deleteRecordedFile: deleteRecordedFile,
                getRawData: getRawData,
                getSampleRate : getSampleRate,
                hasRawData: hasRawData,
                onAudioRemoved: onAudioRemoved,
                encodeM4AB64: encodeM4AB64,
                finalize: finalize
            };
		}

		return IosRecorder;
});
define(
'../utils/platform-utils',[],
function() {
    "use strict";

    var PlatformUtils = {};

    PlatformUtils.isIdevice = function () {
    	return /iphone|ipad|ipod/i.test(navigator.platform)
    };
    PlatformUtils.isAndroid = function () {
        //console.log('navigator.platform:',navigator.platform);
        //return navigator.userAgent.toLowerCase().indexOf('android') > -1;
        //return /Android/i.test(navigator.userAgent);
    };
    PlatformUtils.canTouch = function () {
    	return ("ontouchstart" in document.documentElement)
    };
    PlatformUtils.hasMsTouch = function () {
    	// for point graph on win8 sometime in the future
    	return (window.navigator.msPointerEnabled||false)
    };
    PlatformUtils.usingSafari = function () {
       return (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1 && !this.isIdevice())
    };
    PlatformUtils.usingFF = function () {
        return /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent)
    };
    return PlatformUtils;
});
define(
    'js-player',[
        '../utils/platform-utils'
    ],
    function( PlatformUtils ) {
        function JSPlayer( $container, config, encoder, decoder, controller ) {

            var _decodeStartTime =  0;

            // init code
            var _$audio = $( '<audio/>' )
                .appendTo( $container )
                .on('playing', onPlaybackStart)
                .on('pause', onPlaybackStop)
                .on('ended', onPlaybackEnd);
            var _audio = _$audio[0];
            var isChrome = !!window.chrome;
            var canPlayOggString = _audio.canPlayType('audio/ogg');
            var canPlayOgg = canPlayOggString === 'maybe' || canPlayOggString === 'probably';

            function hasValidRecordingDuration() {
                var duration = getRecordingDuration();
                return !isNaN(duration) && duration > 0;
            }

            function onPlaybackStart() {
                doLog('onPlaybackStart, hasValidRecordingDuration():',hasValidRecordingDuration());
                _$audio.off('timeupdate', onTimeUpdate);
                if ( hasValidRecordingDuration() ) {
                    controller.animPlaybackMarker( 'play' );
                } else {
                    _$audio.on('timeupdate', onTimeUpdate);
                }
                controller.onPlaybackStart();
            }

            function onPlaybackStop() {
                _$audio.off('timeupdate', onTimeUpdate);
                controller.onPlaybackStop();
            }

            function onPlaybackEnd() {
                _$audio.off('timeupdate', onTimeUpdate);
                controller.onPlaybackEnd();
            }

            function onTimeUpdate() {
                doLog('onTimeUpdate, hasValidRecordingDuration():',hasValidRecordingDuration(),', _audio.duration:',_audio.duration);
                if ( hasValidRecordingDuration() ) {
                    _$audio.off('timeupdate', onTimeUpdate);
                    controller.animPlaybackMarker( 'play' );
                }
            }

            function stop() {
                _$audio.off('timeupdate', onTimeUpdate);
                _audio.pause();
                _audio.currentTime = 0;
                controller.onPlaybackStop();
                controller.setState('stop');
            }

            function play() {
                if ( hasPlaybackSource() ) {
                    startPlayback();
                } else {
                    setPlaybackData( true );
                }
            }

            function setPlaybackData( startPlayback, forceDecode ) {
                startPlayback = startPlayback || false;
                forceDecode = forceDecode || false;

                _$audio.html('');

                var b64 = controller.getResponseAudioData();
                if ( typeof b64 === 'string' && b64.length > 0 ) {
                    switch( controller.getRecorderType() ) {
                        case controller.CORDOVA:
                            prepareForPlayback( b64, startPlayback );
                            break;
                        default:
                            if ( !forceDecode && canPlaybackOgg(b64) && config.codec === 'opus') {
                                prepareForPlayback( b64, startPlayback );
                            } else {
                                _decodeStartTime =  window.performance.now();
                                decoder.decode( config.codec, b64 )
                                    .then( function( samples ) {
                                        encoder.encode( 'wav', 'data', samples ).then( function( wavBuffer ) {
                                            prepareForPlayback( wavBuffer, startPlayback );
                                        });
                                    });
                            }
                            break;
                    }
                }
            }

            function prepareForPlayback( data, doStartPlayback, decodeStartTime) {
                var dataType = Object.prototype.toString.call( data );
                var $source;

                if ( dataType === '[object ArrayBuffer]' ) {
                    var blob = new Blob( [ data ], { type: 'audio/wav' } );
                    var blobURL = URL.createObjectURL( blob );
                    $source = $( '<source src="' + blobURL + '" type="audio/wav" />' );
                    if ( !isNaN(decodeStartTime) ) {
                        controller.setDebugValue( 'decode', ((window.performance.now() - decodeStartTime)/1000).toFixed(3) );
                    }
                } else if ( dataType === '[object String]' ) {
                    var src;
                    var type;
                    switch ( controller.getRecorderType() ) {
                        case controller.CORDOVA:
                            src = 'data:audio/x-m4a;base64,' + data;
                            type = 'audio/mp4';
                            break;
                        default:
                            src = 'data:audio/ogg;base64,' + data;
                            type = 'audio/ogg';
                            break;
                    }
                    $source = $( '<source src="'+src+'" type="'+type+'" />' );
                } else {
                    console.error('Audio Recorder > JS Player > prepareForPlayback, data type:',dataType,' is not supported');
                    return;
                }
                if ( typeof doStartPlayback !== 'undefined' && doStartPlayback === true ) {
                    startPlayback( $source );
                } else {
                    setPlaybackSource( $source );
                }
            }

            function startPlayback( $source ) {
                if ( typeof $source !== 'undefined') {
                    setPlaybackSource( $source );
                }
                _audio.play();
                controller.setState('play');
             }

            function setPlaybackSource( $source ) {
                $source.on('error', function(e) {
                    if ( _$audio[0].networkState === _$audio[0].NETWORK_NO_SOURCE ) {
                        var type = $(this).attr('type');
                        if ( type === 'audio/ogg' ) {
                            setPlaybackData(false, true);
                        } else {
                            controller.showPlaybackError(e);
                        }
                    }
                });
                _$audio.html( $source );
                _audio.load();
                controller.setState('stop');
            }

            function hasPlaybackSource() {
                return _$audio.find('source').length > 0;
            }

            function canPlaybackOgg( b64 ) {
                var canPlay = canPlayOgg;
                // if ( isChrome && window.TN8.audioHash.hasOwnProperty( getAudioKey(b64) ) ) {
                //     canPlay = false;
                // }
                //console.log('canPlaybackOgg:',canPlay);
                return canPlay;
            }

            function onAudioRemoved() {
                _$audio.html('');
            }

            function getRecordingDuration() {
                var duration = 0;
                if ( hasPlaybackSource() && _audio && _audio.duration ) {
                    duration = _audio.duration;
                }
                return duration;
            }

            function finalize() {
                _$audio.off();
                _$audio.remove();
                _$audio = null;
                _audio = null;
            }

            function doLog() {
                var args = ['---- JS-Player >'].concat( Array.prototype.slice.call(arguments) );
                console.log.apply( console, args);
            }

            return {
                play: play,
                stop: stop,
                finalize: finalize,
                getRecordingDuration: getRecordingDuration,
                hasValidRecordingDuration: hasValidRecordingDuration,
                prepareForPlayback: prepareForPlayback,
                onAudioRemoved: onAudioRemoved,
                setPlaybackData: setPlaybackData,

                canPlayOgg: canPlayOgg
            };
        }

        return JSPlayer;
});
define(
    'flash-player',[
        '../../libs/performance-now-polyfill'
    ],
    function() {
        function FlashPlayer( $container, config, encoder, decoder, controller ) {
            var _flash;
            var _hasPlaybackSource = false;
            var _recordingDuration = 0;
            var _decodeStartTime = 0;
            var _flashDispatcher = window.TN8.flashRecorder;

            // init code
            _flashDispatcher.addEventListener('flashPlaybackComplete', onFlashPlaybackComplete);
            controller.getRecorder().initDeferred.then( function (flash) {
                _flash = flash;
            });

            function onFlashPlaybackComplete( data ) {
                if ( config.recorderId !== data.recorderId ) { return; }
                updateControllerStateToStop();
            }

            function stop() {
                _flash.stopEither();
                updateControllerStateToStop();
            }

            function updateControllerStateToStop() {
                controller.setState('stop');
                controller.onPlaybackStop('stop');
            }

            function play( quickPlayback ) {
                if ( _hasPlaybackSource || quickPlayback ) {
                    _recordingDuration = _flash.getRecordingDuration();
                    startPlayback();
                } else {
                    var b64 = controller.getResponseAudioData();
                    if ( typeof b64 === 'string' && b64.length > 0 ) {
                        _decodeStartTime =  window.performance.now();
                        decoder.decode( config.codec, b64 )
                            .then( function( float32Array ) {
                                var arrayForFlash = Array.prototype.slice.call( float32Array );
                                _recordingDuration = _flash.setDataForPlayback( arrayForFlash );
                                controller.setDebugValue( 'decode', ((window.performance.now() - _decodeStartTime)/1000).toFixed(3) );
                                startPlayback();
                            });
                    } else {
                        console.error('Audio Recorder playback error. Response encode audio data is undefined, empty, or in an incorrect format');
                    }
                }
            }

            // quick playback for data from setResponse
            function setPlaybackData( startPlayback ) {
                startPlayback = startPlayback || false;
                var b64 = controller.getResponseAudioData();
                if ( typeof b64 === 'string' && b64.length > 0 ) {
                    _decodeStartTime =  window.performance.now();
                    decoder.decode( config.codec, b64 )
                        .then( function( float32Array ) {
                            var arrayForFlash = Array.prototype.slice.call( float32Array );
                            _recordingDuration = _flash.setDataForPlayback( arrayForFlash );
                            controller.setDebugValue( 'decode', ((window.performance.now() - _decodeStartTime)/1000).toFixed(3) );
                            _hasPlaybackSource = true;
                            controller.setState('stop');
                        });
                }
            }

            function startPlayback() {
                // if playback is starting, we now have a playback source
                // this gets set to false if we delete the current recording
                _hasPlaybackSource = true;
                _flash.play();
                controller.setState( 'play' );
                controller.onPlaybackStart();
                controller.animPlaybackMarker( 'play' );
            }

            function onAudioRemoved() {
                _hasPlaybackSource = false;
            }

            function getRecordingDuration() {
                var duration = 0;
                if ( _hasPlaybackSource && _recordingDuration ) {
                    duration = _recordingDuration;
                }
                return duration;
            }

            function finalize() {
                if ( _flashDispatcher ) {
                    _flashDispatcher.removeEventListener('flashPlaybackComplete', onFlashPlaybackComplete);
                }
                _flashDispatcher = null;
                _flash = null;
            }

            return {
                play: play,
                stop: stop,
                finalize: finalize,
                getRecordingDuration: getRecordingDuration,
                onAudioRemoved: onAudioRemoved,
                canPlayOgg: false,
                setPlaybackData: setPlaybackData
            };
        }

        return FlashPlayer;
});
!function(a){"use strict";function b(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c}function c(a,b){return a<<b|a>>>32-b}function d(a,d,e,f,g,h){return b(c(b(b(d,a),b(f,h)),g),e)}function e(a,b,c,e,f,g,h){return d(b&c|~b&e,a,b,f,g,h)}function f(a,b,c,e,f,g,h){return d(b&e|c&~e,a,b,f,g,h)}function g(a,b,c,e,f,g,h){return d(b^c^e,a,b,f,g,h)}function h(a,b,c,e,f,g,h){return d(c^(b|~e),a,b,f,g,h)}function i(a,c){a[c>>5]|=128<<c%32,a[(c+64>>>9<<4)+14]=c;var d,i,j,k,l,m=1732584193,n=-271733879,o=-1732584194,p=271733878;for(d=0;d<a.length;d+=16)i=m,j=n,k=o,l=p,m=e(m,n,o,p,a[d],7,-680876936),p=e(p,m,n,o,a[d+1],12,-389564586),o=e(o,p,m,n,a[d+2],17,606105819),n=e(n,o,p,m,a[d+3],22,-1044525330),m=e(m,n,o,p,a[d+4],7,-176418897),p=e(p,m,n,o,a[d+5],12,1200080426),o=e(o,p,m,n,a[d+6],17,-1473231341),n=e(n,o,p,m,a[d+7],22,-45705983),m=e(m,n,o,p,a[d+8],7,1770035416),p=e(p,m,n,o,a[d+9],12,-1958414417),o=e(o,p,m,n,a[d+10],17,-42063),n=e(n,o,p,m,a[d+11],22,-1990404162),m=e(m,n,o,p,a[d+12],7,1804603682),p=e(p,m,n,o,a[d+13],12,-40341101),o=e(o,p,m,n,a[d+14],17,-1502002290),n=e(n,o,p,m,a[d+15],22,1236535329),m=f(m,n,o,p,a[d+1],5,-165796510),p=f(p,m,n,o,a[d+6],9,-1069501632),o=f(o,p,m,n,a[d+11],14,643717713),n=f(n,o,p,m,a[d],20,-373897302),m=f(m,n,o,p,a[d+5],5,-701558691),p=f(p,m,n,o,a[d+10],9,38016083),o=f(o,p,m,n,a[d+15],14,-660478335),n=f(n,o,p,m,a[d+4],20,-405537848),m=f(m,n,o,p,a[d+9],5,568446438),p=f(p,m,n,o,a[d+14],9,-1019803690),o=f(o,p,m,n,a[d+3],14,-187363961),n=f(n,o,p,m,a[d+8],20,1163531501),m=f(m,n,o,p,a[d+13],5,-1444681467),p=f(p,m,n,o,a[d+2],9,-51403784),o=f(o,p,m,n,a[d+7],14,1735328473),n=f(n,o,p,m,a[d+12],20,-1926607734),m=g(m,n,o,p,a[d+5],4,-378558),p=g(p,m,n,o,a[d+8],11,-2022574463),o=g(o,p,m,n,a[d+11],16,1839030562),n=g(n,o,p,m,a[d+14],23,-35309556),m=g(m,n,o,p,a[d+1],4,-1530992060),p=g(p,m,n,o,a[d+4],11,1272893353),o=g(o,p,m,n,a[d+7],16,-155497632),n=g(n,o,p,m,a[d+10],23,-1094730640),m=g(m,n,o,p,a[d+13],4,681279174),p=g(p,m,n,o,a[d],11,-358537222),o=g(o,p,m,n,a[d+3],16,-722521979),n=g(n,o,p,m,a[d+6],23,76029189),m=g(m,n,o,p,a[d+9],4,-640364487),p=g(p,m,n,o,a[d+12],11,-421815835),o=g(o,p,m,n,a[d+15],16,530742520),n=g(n,o,p,m,a[d+2],23,-995338651),m=h(m,n,o,p,a[d],6,-198630844),p=h(p,m,n,o,a[d+7],10,1126891415),o=h(o,p,m,n,a[d+14],15,-1416354905),n=h(n,o,p,m,a[d+5],21,-57434055),m=h(m,n,o,p,a[d+12],6,1700485571),p=h(p,m,n,o,a[d+3],10,-1894986606),o=h(o,p,m,n,a[d+10],15,-1051523),n=h(n,o,p,m,a[d+1],21,-2054922799),m=h(m,n,o,p,a[d+8],6,1873313359),p=h(p,m,n,o,a[d+15],10,-30611744),o=h(o,p,m,n,a[d+6],15,-1560198380),n=h(n,o,p,m,a[d+13],21,1309151649),m=h(m,n,o,p,a[d+4],6,-145523070),p=h(p,m,n,o,a[d+11],10,-1120210379),o=h(o,p,m,n,a[d+2],15,718787259),n=h(n,o,p,m,a[d+9],21,-343485551),m=b(m,i),n=b(n,j),o=b(o,k),p=b(p,l);return[m,n,o,p]}function j(a){var b,c="";for(b=0;b<32*a.length;b+=8)c+=String.fromCharCode(a[b>>5]>>>b%32&255);return c}function k(a){var b,c=[];for(c[(a.length>>2)-1]=void 0,b=0;b<c.length;b+=1)c[b]=0;for(b=0;b<8*a.length;b+=8)c[b>>5]|=(255&a.charCodeAt(b/8))<<b%32;return c}function l(a){return j(i(k(a),8*a.length))}function m(a,b){var c,d,e=k(a),f=[],g=[];for(f[15]=g[15]=void 0,e.length>16&&(e=i(e,8*a.length)),c=0;16>c;c+=1)f[c]=909522486^e[c],g[c]=1549556828^e[c];return d=i(f.concat(k(b)),512+8*b.length),j(i(g.concat(d),640))}function n(a){var b,c,d="0123456789abcdef",e="";for(c=0;c<a.length;c+=1)b=a.charCodeAt(c),e+=d.charAt(b>>>4&15)+d.charAt(15&b);return e}function o(a){return unescape(encodeURIComponent(a))}function p(a){return l(o(a))}function q(a){return n(p(a))}function r(a,b){return m(o(a),o(b))}function s(a,b){return n(r(a,b))}function t(a,b,c){return b?c?r(b,a):s(b,a):c?p(a):q(a)}"function"==typeof define&&define.amd?define('md5.min',[],function(){return t}):a.md5=t}(this);
define(
    'recorder',[
        'encoder',
        'decoder',
        'webrtc-recorder',
        'flash-recorder',
        'ios-recorder',
        'js-player',
        'flash-player',
        'md5.min',
        '../../libs/performance-now-polyfill'
    ],
    function( Encoder, Decoder, WebRtcRecorder, FlashRecorder, NativeRecorder, JSPlayer, FlashPlayer, MD5 ) {
        function Recorder( config, $container ) {
            var RECORDING_COMPLETED = ($.i18n ? $.i18n.t("audioRecorder:recordingComplete") : 'Recording complete.');
            var NO_SUPPORT_MSG = '<i class="icon-warning-sign before-text"></i>' + ($.i18n ? $.i18n.t("audioRecorder:recordingNotSupported") : 'Your browser does not support recording audio.');
            var NO_PLAYBACK_MSG = '<i class="icon-warning-sign before-text"></i>' + ($.i18n ? $.i18n.t("audioRecorder:playbackNotSupported") : 'Your browser does not support audio playback.');
            var ATTEMPTS = ($.i18n ? $.i18n.t("audioRecorder:remainingAttempts") : 'Remaining attempts:') + " ";
            var DELETE_MSG = '<i class="icon-warning-sign before-text"></i><span>' + ($.i18n ? $.i18n.t("audioRecorder:deleteRecording") : 'Delete the current recording?') + '</span>';
            var CANCEL = '<i class="icon-ban-circle before-text"></i>' + ($.i18n ? $.i18n.t("cancel") : 'Cancel');
            var DELETE = '<i class="icon-trash before-text"></i>' + ($.i18n ? $.i18n.t("delete") : 'Delete');
            var MAX_RECORDING_TIME = 300; // in seconds

            // Recorder Type constants
            var WEBRTC = 1;
            var FLASH = 2;
            var CORDOVA = 3;

            var _encoder;
            var _decoder;
            var _recorder;
            var _player;

            var _times;
            var _elapsedTime; // time of current recording in milliseconds

            var _canvas;
            var _response;
            var _id;
            var _responseIdentifier;
            var _audio;
            var _remainingAttempts;
            var _recorderType;
            var _timeoutId = null;
            var _debugDisplay = false;

            // stored for pending encode request for getResponse
            var _pendingEncodeForResponse = false;
            var _progressiveEncodeDeferred = null;
            var _startEncodingTime = 0;

            // playback/recodrer configuration options
            var _canSetPlaybackOptions = true;
            var _quickPlayback = true;
            var _flashRecord = false;
            var _flashPlayback = false;
            var _useFlashEncoding = false;
            var _progressiveEncode = true;
            var _codec = 'opus'; // 'spx'
            // flag to have opus progressive encoding use the returned b64 for quickplay vs encoding the raw data to wav
            var _opusProgressiveQuickPlayUseB64 = true;

            // possible state values: 'init', 'denied', 'allowed', 'reset', 'permission', 'record', 'play', 'stop', 'pending'
            var _state = null;
            var _prevState = null;
            // flag for touchend so as not to handle touchend and click
            var touchendHandled = false;

            // jquery wrapped DOM element references
            var _$main, _$spinner, _$controlBtn, _$controlBtnIcon, _$debug, _$canvas, _$clearBtn, _$progress, _$bar, _$marker, _$statusDisplay, _$speakerIcon, _$message, _$attempts, _$deleteDialog, _$cancelDelete, _$confirmDelete;

            /**********************************************************
             *                 public API methods
             **********************************************************/

            function init() {
                navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || null;
                _id = uniqueId();
                _responseIdentifier = getResponseIdentifier();
                setConfigDefaults();
                _remainingAttempts = config.attempts;
                _response = { data: '', answered: false, codec: _codec };
                _times = {
                    totalRecordingTime: parseRecordingLength( config.recordingLength )
                };
                config.totalRecordingTime = _times.totalRecordingTime;
                // condition for non-tn8 or non-tei pathing
                var origin = window.location.origin || window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
                if ( window.TN8 && window.TN8.hasOwnProperty('audioBaseUrl') ) {
                     config.hasAudioBaseUrl = true;
                     config.baseURL = window.TN8.audioBaseUrl;
                } else {
                    config.teiRepo = window.location.pathname.indexOf('/tei/') > -1;
                    if ( window.TN8 ) {
                        // should be in the client
                        config.baseURL = !window.TN8.baseUrl ? origin + '/client/' : window.TN8.baseUrl;
                        config.useBlob = true;
                    } else if ( config.teiRepo ) {
                        // no TN8 object and we are in tei
                        config.baseURL = origin + '/tei/';
                    } else {
                        console.error('ERROR! in TN8 client and window.TN8 does not exist');
                    }
                }
                // if we are using blob uri for web workers,
                // config.baseURL needs to be absolute path, not relative or root-relative
                if ( config.useBlob === true && config.baseURL.indexOf('http') === -1 && config.baseURL.indexOf('//') === -1) {
                    config.baseURL =  origin + config.baseURL;
                }

                window.TN8 = window.TN8 || {};
                window.TN8.audioHash = window.TN8.audioHash || {};

                //console.log('config.baseURL:',config.baseURL,', config.useBlob:',config.useBlob);
                setupUI();

                // we can set a coded flag to force flash recording and/or playback. used for dev/testing.
                if ( _flashRecord || _flashPlayback ) {
                    _recorderType = FLASH;
                    _recorder = new FlashRecorder( $container, config );
                } else {
                    if ( navigator.getUserMedia ) { //our browser supports media capture
                        _recorderType = WEBRTC;
                        _recorder = new WebRtcRecorder( $container, config );
                    } else if ( !navigator.userAgent.toLowerCase().match( /(iphone|ipod|ipad)/i ) ) { //fallback to the flash recorder for browsers without media capture support
                        _flashRecord = true;
                        _recorderType = FLASH;
                        _recorder = new FlashRecorder( $container, config );
                    } else if ( navigator.userAgent.toLowerCase().match( /(iphone|ipod|ipad)/i ) ) { // native iOS recorder (cordova)
                        _recorderType = CORDOVA;
                        _recorder = new NativeRecorder( $container, config );
                    } else {
                        console.error("Recorder init failed, platform not supported.");
                        $container.trigger( "not-supported.VoiceRecorder");
                        setComplete( NO_SUPPORT_MSG );
                    }
                }
                if ( _recorder ) {
                    setState('pending');
                    _recorder.initDeferred.then( $.proxy(onRecorderReady, this) );
                }
            }

            function showPlaybackError( error ) {
                setComplete( NO_PLAYBACK_MSG );
                console.log('showPlaybackError, error:',error,', ');
            }

            function onRecorderReady() {
                //console.log('onRecorderReady');
                _encoder = new Encoder( $container, config );
                _decoder = new Decoder( $container, config );
                if ( config.allowReview ) {
                    // if is IE or we set the hard-coded flag to use flash for playback, use flash, else use javascript
                    if ( 'ActiveXObject' in window || _flashPlayback || (_quickPlayback && _recorderType === FLASH) ) {
                        _player = new FlashPlayer( $container, config, _encoder, _decoder, this );
                        _flashPlayback = true;
                    } else {
                        _player = new JSPlayer( $container, config, _encoder, _decoder, this);
                    }
                }
                setState('init');
                $(document).off( 'tn.ews.on tn.error.fatal timerTimeout', stop );
                $(document).on( 'tn.ews.on tn.error.fatal timerTimeout', stop );

                _opusProgressiveQuickPlayUseB64 = _opusProgressiveQuickPlayUseB64 && _progressiveEncode && _quickPlayback && _player && _player.canPlayOgg;

                // if there wasnt a recording smaple rate specified in the config, use the _reocrders sample rate
                if ( !config.recordingOptions.sampleRate ) {
                    config.recordingOptions.sampleRate = _recorder.getSampleRate();
                }

                if ( _debugDisplay ) {
                    var $debug = $( '<div class="debug"><label>Encode Time:<span class="encode"></span></label><label>Decode Time:<span class="decode"></span></label><label>Audio duration:<span class="audio"></span></label><label>Progressive Encode:<span class="progressive"></span></label><label>Quick Playback:<span class="quick-playback"></span></label><label>Flash Record:<span class="flash-record"></span></label><label>Flash Playback:<span class="flash-playback"></span></label></div>' )
                        .appendTo( $container );
                    setDebugValue('progressive', _progressiveEncode );
                    setDebugValue('quick-playback', _quickPlayback );
                    setDebugValue('flash-record', _flashRecord );
                    setDebugValue('flash-playback', _flashPlayback );
                    if ( _quickPlayback && _flashPlayback || _opusProgressiveQuickPlayUseB64) {
                        $debug.find('.decode').parent().remove();
                    }
                }
            }


            function isAnswered() {
                return _response.answered || hasRawAudioData();
            }

            function getResponseData() {
                var triggerNow = false;
                if( _response && _response.answered === true ) {
                    triggerNow = true;
                }
                else {
                    // if recording, stop recording. this will also retrieve
                    // the raw recorded data from the recorder
                    if( isRecording() ) {
                        // we are in process of encoding (stopRecord calls encodeB64)
                        _pendingEncodeForResponse = true;
                        stopRecord();
                    }
                    // if we have raw recorded data that isn't encoded, set a pending flag,
                    // and store the itemID and responseID to use to send response once encoding is done
                    else if ( hasRawAudioData() ) {
                        // we are in process of encoding
                        _pendingEncodeForResponse = true;
                        encodeB64();
                    }
                    else {
                        // otherwise, we have an unaswered item, so send the unanswered response
                        triggerNow = true;
                    }
                }
                // the audio data is not in a state pending an encode (we either have a response
                //  or an un-answered response) so dispatch event for getResponseData
                var removeProps = [ 'recorderId', 'blob' ];
                if ( triggerNow ) {
                    $.each( removeProps, function (index, key) {
                        if ( _response.hasOwnProperty( key ) ) {
                            delete _response[ key ];
                        }
                    });
                    // if unlimited attempts, do not send a remainingAttempts response property
                    if ( config.attempts === 0 ) {
                        delete _response.remainingAttempts;
                    } else {
                        _response.remainingAttempts = _remainingAttempts;
                    }
                    $(document).trigger( 'TN8.Application.RecorderResponse', [ _responseIdentifier, _response ] );
                    //  we can clear out the flags needed for a pending response waiting to finish encoding
                    _pendingEncodeForResponse = false;
                }
            }

            function setResponseData( response ) {
                //console.log('---- setResponseData, _recorder.initDeferred.isResolved():',_recorder.initDeferred.isResolved(),', response:',response);

                // the recorder might not be ready yet, so queue this on the recorder init deferred
                // resolved callback list to ensure the rest of this is called once the recorder is ready
                if (  _recorder && !_recorder.initDeferred.isResolved() ) {
                    _recorder.initDeferred.then( $.proxy(setResponseData, this, response) );
                    return;
                }

                stop();

                // if there is a response argument, update _response property
                if ( response && response.hasOwnProperty('data') && response.hasOwnProperty('answered') && Object.prototype.toString.call(response) === '[object Object]' ) {
                    _response = { data: '', answered: false, codec: _codec };
                    // set properties from response
                    // data : String (base64 audio), answered : Boolean
                    if( response.data && response.data.length > 0 ) {
                        _response.data = response.data;
                        _response.answered = true;
                        console.log('MD5(_response.data):',MD5(_response.data));
                    }
                    // remainingAttempts : Number
                    if ( response.hasOwnProperty('remainingAttempts') ) {
                        _remainingAttempts = response.remainingAttempts;
                        // update remaining attempts text
                        _$attempts.text( ATTEMPTS + _remainingAttempts);
                    }
                    // codec : String
                    if ( response.hasOwnProperty('codec') ) {
                        _codec = config.codec = _response.codec = response.codec;
                    }
                }
                // if this is answered, update ui state
                if ( _response.answered ) {
                    removeAudio(true);
                    // if quickPlayback is enabled, set recorder and player data
                    if ( _player && _quickPlayback ) {
                        setState('pending');
                        _player.setPlaybackData();
                        //_player.setDataForQuickPlay();
                    } else {
                        setState( 'stop' );
                        animRecordingBar( 'stop' );
                    }
                }
            }

            function setAudioKey( b64 ) {
                window.TN8 = window.TN8 || {};
                window.TN8.audioHash = window.TN8.audioHash || {};
                var hash = MD5( b64 );
                if ( !window.TN8.audioHash.hasOwnProperty(hash) ) {
                    window.TN8.audioHash[ hash ] = true;
                } else {
                    console.error('AudioRecorder > hash already exist for b64 audio');
                }
            }

            function getAudioFromKey( b64 ) {
                window.TN8 = window.TN8 || {};
                window.TN8.audioHash = window.TN8.audioHash || {};
                var hash = MD5( b64 );
                return window.TN8.audioHash.hasOwnProperty(hash);
            }

            function getResponseAudioData( type ) {
                var data;
                if ( hasEncodedAudio(type) ) {
                    data = type === 'blob' ? _response.blob : _response.data;
                }
                return data;
            }

            function getResponseAudioBlob() {
                var blob;
                if ( hasEncodedAudio() ) {
                    b64 = _response.data;
                }
                return b64;
            }

            function onPlaybackStart() {
               setDebugValue( 'audio', getRecordingDuration(false).toFixed(3) );
                // shouldn't this work the same for all recorders?
                if (_recorderType !== CORDOVA) {
                    // this call below is now made by the player when the data (audio duration)
                    // needed to animate the the playback marker is available
                    // animPlaybackMarker( 'play' );
                }
                $container.trigger('playback-start.VoiceRecorder');
            }

            function onPlaybackEnd() {
                setState('stop');
            }

            function onPlaybackStop() {
                animPlaybackMarker( 'reset' );
                $container.trigger('playback-stop.VoiceRecorder');
            }

            function getRecorderType() {
                return _recorderType;
            }
            function finalize() {
                $(document).off( 'tn.ews.on tn.error.fatal timerTimeout', stopRecord );

                $.each( [ _recorder, _encoder, _decoder, _player ], function ( index, caller ) {
                    if ( caller && caller.finalize ) {
                        caller.finalize();
                    }
                });

                _recorder = null;
                _encoder = null;
                _decoder = null;
                _player = null;

                // remove DOM bound event listeners
                $.each( [ $container, _$controlBtn, _$clearBtn, _$cancelDelete, _$confirmDelete ], function( idx, $elem ) {
                    if ( $elem && $elem.off && typeof $elem.off === 'function' ) {
                        $elem.off();
                    }
                });
            }

            function stop() {
                switch ( _state ) {
                    case 'record':
                        stopRecord();
                        break;
                    case 'play':
                        stopPlay();
                        break;
                }
            }

            /**************************************************
             *       control button methods (handlers)
             **************************************************/

            function getRecorder() {
                return _recorder;
            }

            function startRecord() {
                setDebugValue( 'encode', '');
                setDebugValue( 'audio', '');

                removeAudio();
                // sample rate needs to be set for opus encoding
                if ( !config.recordingOptions.hasOwnProperty('sampleRate') ) {
                    config.recordingOptions.sampleRate = _recorder.getSampleRate();
                }
                setState('permission'); // Let this be here until Mic check is implemented
                if ( _recorderType == CORDOVA ) {
                    _timeoutId = window.setTimeout( stopRecord, _times.totalRecordingTime );
                    setState('record');
                }
                _recorder.startRecording();
            }

            function stopRecord() {
                if ( _recorderType == CORDOVA && _timeoutId !== null ) {
                    window.clearTimeout( _timeoutId );
                }
                _timeoutId = null;
                _canvas.width = _canvas.width;
                _recorder.stopRecording();
                clearCanvas( _canvas.getContext( "2d" ) );
                setState('stop');
                $container.trigger('record-stop.VoiceRecorder');
                _startEncodingTime = window.performance.now();

                // if quick playback is enabled, encode raw data for playback
                if ( _quickPlayback && _player ) {
                    encodeForQuickPlayback();
                }
                // encode recording to base64
                if ( hasRawAudioData() ) {
                    encodeB64();
                }
            }

            function startPlay() {
                // sample rate needs to be set for opus encoding
                if ( !config.recordingOptions.hasOwnProperty('sampleRate') ) {
                    config.recordingOptions.sampleRate = _recorder.getSampleRate();
                }

                if ( _player ) {
                    _player.play( _quickPlayback );
                }
            }

            function stopPlay() {
                if ( _player ) {
                    _player.stop();
                }
            }

            /**************************************************
             *                event handlers
             **************************************************/

            // deferred object callback from encodeB64
            function onAudioEncodedToB64( b64 ) { //, blob ) {
                setDebugValue( 'encode', ((window.performance.now() - _startEncodingTime)/1000).toFixed(3) );
                // store updated response
                _response = { data: b64, answered: true, codec: config.codec };
                // let the client know the response state has changed
                $(document).trigger( 'ItemResponseChanged' );
                // if we had a pending get response call that occured before the
                // response data was encoded, call getResponseData again now that
                // the response has been set to trigger that event
                if ( _pendingEncodeForResponse ) {
                    getResponseData();
                    _pendingEncodeForResponse = false;
                }
                if ( _opusProgressiveQuickPlayUseB64 && _player ) {
                    _player.prepareForPlayback( b64 );
                    setState('stop');
                } else if ( !_quickPlayback ) {
                    setState('stop');
                }
            }

            // _recorder 'audioenabled' handler
            function handleRecordingStarted() {
                // set delay timer for stop
                window.setTimeout( function() {
                    _$controlBtn.removeAttr('disabled');
                }, 250);

                _$controlBtn.attr('disabled', true);
                setState('record');

                $container.trigger('record-start.VoiceRecorder');
            }

            // _recorder 'audioinput' handler
            function handleInput( e, data ) {
                var buffers = data;
                var micLevel = rms( buffers ) * 3;
                onInputHandled( micLevel );
                if ( _progressiveEncode ) {
                    var deferred = _encoder.encode( 'opus', 'b64', [buffers], true, false );
                    // deferred object returned from first progressive encode call. otherwise, undefiend returned
                    if ( typeof deferred !== 'undefined' ) {
                        _progressiveEncodeDeferred = deferred;
                    }
                }
            }

            // handles amplitude levels from flash recorder and ios recorder 'micSampleData' event
            function handleMicSampleData( e, micLevel ) {
                onInputHandled( micLevel/100 );
            }

            function onInputHandled( micLevel ) {
                if( !_times.startTime ) {
                    _times.startTime = window.performance.now();
                    _times.intervalTime = _times.startTime;
                }
                var elapsedInterval = window.performance.now() - _times.intervalTime;
                if( elapsedInterval >= 17 ) {
                    _times.intervalTime = elapsedInterval + _times.intervalTime;
                    updateProgress();
                    drawMeter( _canvas.getContext( "2d" ), micLevel );
                }
            }

            /**************************************************
             *           button event handlers
             **************************************************/

            function onControlButtonAction( e ) {
                if ( e.type === 'touchend' ) {
                    touchendHandled = true;
                }
                if ( e.type === 'click' && touchendHandled ) {
                    touchendHandled = false;
                    return;
                }
                switch (_state) {
                    case 'record':
                        stopRecord();
                        break;
                    case 'play':
                        stopPlay();
                        break;
                    case 'stop':
                        setState('pending');
                        startPlay();
                        break;
                    case 'init':
                    case 'allowed':
                    case 'reset':
                        startRecord();
                        break;
                    case 'denied':
                        break;
                }
            }

            function showDeleteDialog( e ) {
                if ( e.type === 'touchend' ) {
                    touchendHandled = true;
                }
                if ( e.type === 'click' && touchendHandled ) {
                    touchendHandled = false;
                    return;
                }
                toggleDeleteDialog(true);
            }

            function confirmDelete( e ) {
                if ( !!e && e.type === 'touchend' ) {
                    touchendHandled = true;
                }
                if ( !!e && e.type === 'click' && touchendHandled ) {
                    touchendHandled = false;
                    return;
                }
                removeAudio();
                setState('reset');
                toggleDeleteDialog(false);
            }

            function cancelDelete( e ) {
                if ( e.type === 'touchend' ) {
                    touchendHandled = true;
                }
                if ( e.type === 'click' && touchendHandled ) {
                    touchendHandled = false;
                    return;
                }
                toggleDeleteDialog(false);
            }

            /**************************************************
             *           private methods
             **************************************************/

            function encodeForQuickPlayback() {
                switch ( _recorderType) {
                    case WEBRTC:
                        setState('pending');
                        if ( !_opusProgressiveQuickPlayUseB64 ) {
                            _encoder.encode( 'wav', 'data', _recorder.getRawData() ).then( function( wavBuffer ) {
                                _player.prepareForPlayback( wavBuffer, undefined, window.performance.now() );
                                setState('stop');
                            });
                        }
                        break;
                    case FLASH:
                        // nothing needed here because flash already has the recording as
                        // a byte array and that can be used for playback
                        break;
                    case CORDOVA:
                        // TODO: what needs to happen here?
                        break;
                }
            }

            function encodeB64() {
                if ( !_quickPlayback ) {
                    setState('pending');
                }
                switch ( _recorderType) {
                    case WEBRTC:
                    case FLASH:
                        if ( _progressiveEncode ) {
                            // make ending call for progressive encode
                            _encoder.encode( 'opus', 'b64', undefined, true, true );
                            // handle data back from progressive encode
                            _progressiveEncodeDeferred.then( function( b64, blob ) {
                                _progressiveEncodeDeferred = null;
                                onAudioEncodedToB64( b64, blob );
                            });
                        } else {
                            _encoder.encode( config.codec, 'b64', _recorder.getRawData(config.codec === 'opus') ).then( onAudioEncodedToB64 );
                        }
                        break;
                    case CORDOVA:
                        _recorder.encodeM4AB64().then( onAudioEncodedToB64);
                        break;
                }
            }

            function removeAudio(leaveResponse) {
                // terminate workers
                if ( _encoder ) {
                    _encoder.terminateAll();
                }
                if ( _decoder ) {
                    _decoder.terminateAll();
                }
                // let recorder and player handle audio removed
                if ( _recorder ) {
                    _recorder.onAudioRemoved();
                }

                if (_player && _player.onAudioRemoved ) {
                    _player.onAudioRemoved();
                }
                // reset response
                if ( leaveResponse !== true ) {
                    _response = { data: '', answered: false, codec: _codec };
                }
                // delete startTime
                if ( _times && _times.hasOwnProperty('startTime') ) {
                    delete _times.startTime;
                }
                // notify that response changed
                $(document).trigger( 'ItemResponseChanged' );
            }

            function hasEncodedAudio( type ) {
                var hasEncoded = _response && _response.hasOwnProperty('data') && typeof _response.data === 'string' && _response.data.length > 0;
                if (type === 'blob') {
                    hasEncoded = hasEncoded && _response.hasOwnProperty('blob') && Object.prototype.toString.call(_response.blob) === '[object Blob]';
                }
                return hasEncoded;
            }

            function hasRawAudioData() {
                return _recorder.hasRawData(); //_float32Array !== null && _float32Array.length > 0;
            }

            function setupUI() {
                var inputEvent = 'touchend click';
                //var inputEvent = _recorderType === CORDOVA ? 'touchstart' : 'click';
                $container.addClass( 'tn8-recorder' );
                // $container event handlers
                $container.on( "audioinput", handleInput )
                    .on( "audioenabled", handleRecordingStarted )
                    .on( "micSampleData", handleMicSampleData );
                // DOM elements and add needed button handlers
                _$main = $( '<div class="main"></div>' )
                    .appendTo( $container );
                _$controlBtn = $( '<button class="control-button btn"><div class="btn-icon"></div></button>' )
                    .appendTo( _$main )
                    .on( inputEvent, onControlButtonAction );
                _$spinner = $( '<div class="spinner"></div>' )
                    .appendTo( _$main );
                _$controlBtnIcon = _$controlBtn.find('.btn-icon');
                _$statusDisplay = $( '<div class="status-display"></div>' )
                    .appendTo( _$main );
                _$speakerIcon = $('<div class="speaker-icon"></div>')
                    .appendTo( _$statusDisplay )
                    .hide();
                _$message = $( '<div class="message">' + RECORDING_COMPLETED + '</div>' )
                    .appendTo( _$statusDisplay )
                    .hide();
                _$attempts = $( '<div class="attempts">' + ATTEMPTS + config.attempts + '</div>' )
                    .appendTo( _$statusDisplay )
                    .hide();
                _$clearBtn = $( '<button class="clear-button btn"><i class="icon-trash"></i></button>' )
                    .appendTo( _$main )
                    .hide()
                    .on( inputEvent, showDeleteDialog);

                _$canvas = $('<canvas class="input-meter" />')
                    .appendTo( _$main );
                _canvas = _$canvas[ 0 ];
                _canvas.width = 28;
                _canvas.height = 40;

                _$progress = $( '<div class="progress"><div class="bar reset"></div><div class="marker"></div></div>' )
                    .appendTo( $container );
                _$bar = _$progress.find('.bar');
                _$marker = _$progress.find('.marker');

                // delete dialog DOM element and handlers
                _$deleteDialog = $( '<div class="delete-dialog"><div class="delete-message">'+DELETE_MSG+'</div><div class="button-holder"></div>' )
                    .appendTo( $container )
                    .hide();
                var $buttonHolder = _$deleteDialog.find('.button-holder');
                 _$cancelDelete = $( '<button class="cancel-button btn">'+CANCEL+'</button>' )
                    .appendTo( $buttonHolder )
                    .on( inputEvent, cancelDelete );
                _$confirmDelete = $( '<button class="confirm-button btn">'+DELETE+'</button>' )
                    .appendTo( $buttonHolder )
                    .on( inputEvent, confirmDelete );
            }

            function setState(state) {
                _prevState = _state;
                _state = state;
                //console.log('Recorder > setState, _id:',_id,', _state:',_state,', _prevState:',_prevState);
                _$controlBtn.removeClass('visibily-hidden');
                _$controlBtn.show();
                _$clearBtn.hide();
                _$canvas.hide();
                _$spinner.hide();
                switch (state) {
                case 'init':
                case 'denied':
                case 'allowed':
                case 'reset':
                    animRecordingBar('reset');
                    toggleIcon('record');
                    _$bar.removeClass('reset playing paused')
                        .addClass('reset');
                    break;
                case 'permission':
                    _$controlBtn.hide();
                    break;
                case 'record':
                    _$canvas.show();
                    animRecordingBar('play');
                    toggleIcon('stop');
                    break;
                case 'play':
                    toggleIcon('stop');
                    break;
                case 'stop':
                    animRecordingBar('stop');
                    if (_prevState === 'record') {
                        if ( config.attempts !== 0 ) {
                            _remainingAttempts--;
                        }
                    }
                    if ( config.allowReview ) {
                        toggleIcon('play');
                        _$clearBtn.toggle(  _remainingAttempts > 0 || config.attempts === 0 );
                    } else if ( _remainingAttempts > 0 || config.attempts === 0) {
                        toggleIcon('record');
                        _$controlBtn.addClass('visibily-hidden');
                        _$clearBtn.show();
                    } else {
                        setComplete( RECORDING_COMPLETED );
                    }
                    break;
                case 'pending':
                    _$controlBtn.hide();
                    _$spinner.show();
                    break;
                }

                _$message.hide();
                _$attempts.hide();
                // update ui - depends on recording state or not
                // update status display - depends on: isRecording(), response.answered, and config.attempts
                if ( !isRecording() ) {
                    $container.removeClass('recording');
                    _$controlBtn.removeClass( 'btn-inverse' );

                    if ( _response && (_response.answered === true || _recorder.hasRawData()) )  {
                        _$message.show();
                    }
                    if ( config.attempts > 1) {
                        _$attempts.show();
                        _$attempts.text( ATTEMPTS + _remainingAttempts);
                    }
                } else {
                    $container.addClass('recording');
                    _$controlBtn.addClass( 'btn-inverse' );
                }
                _$speakerIcon.toggle( isRecording() );
            }

            function setDebugValue( className, value ) {
                if ( _debugDisplay ) {
                    $container.find( '.'+className ).text( value );
                }
            }

            function toggleIcon( state ) {
                _$controlBtnIcon.removeClass('play pause record stop')
                    .addClass(state);
            }

             function toggleDeleteDialog(show) {
                var fn = show ? _$bar.addClass : _$bar.removeClass;
                fn.call( _$bar, 'visibily-hidden' );
                _$deleteDialog.toggle( show );
            }

            function setComplete( msg ) {
                _$main.addClass('complete');
                _$controlBtn.addClass('visibily-hidden');
                _$spinner.hide();
                $container.removeClass( 'recording' );
                _$progress.hide();
                _$clearBtn.hide();
                _$attempts.hide();
                _$message.html( msg ).show();

                if ( msg === NO_PLAYBACK_MSG && config.attempts !== 0 ) {
                    if ( _remainingAttempts > 0 ) {
                        _$clearBtn.show();
                        if ( config.attempts > 1 ) {
                            _$attempts.show();
                        }
                    }
                }
            }

            function animRecordingBar( state ) {
                _$bar.removeClass('playing stopped reset');
                switch (state) {
                case 'play':
                    _$bar.attr('style', getTransDurationOptionsArray().join( ':' + getRecordingDuration(true) + 's' + ';' ) )
                        .addClass('playing');
                    break;
                case 'stop':
                    _$bar.addClass('stopped');
                    break;
                case 'reset':
                    _$bar.addClass('reset');
                    break;
                }
            }

            // this method is now called by the player for the 'play' case
            // the player now waits until the audio duration is known to make this call
            // that duration is adjusted to accommodate for the current playback position
            function animPlaybackMarker( state ) {
                _$marker.removeClass('playing reset');
                switch (state) {
                case 'play':
                    var style = getTransDurationOptionsArray().join( ':' + getRecordingDuration(false) + 's;' );
                    _$marker.attr('style',  style)
                        .addClass('playing');
                    break;
                case 'reset':
                    _$marker.addClass('reset');
                    break;
                }
            }

            function updateProgress() {
                _elapsedTime = _times.intervalTime - _times.startTime;
                var progress = _elapsedTime / _times.totalRecordingTime * 100;
                if ( progress >= 100 ) {
                    // stop recording
                    _elapsedTime = _times.totalRecordingTime;
                    stopRecord();
                }
            }

            // canvas - input meter drawing methods
            function clearCanvas( context ) {
                context.clearRect( 0, 0, _canvas.width, _canvas.height );
            }

            function drawMeter( context, rms ) {
                if( isRecording() ) {
                    clearCanvas( context );
                    colorVizByRMS( context, rms );
                }
            }

            function colorVizByRMS( context, rms ) {
                var width = 28;
                var vStep = 5;
                var height = 3;
                //rms *= 3;
                if( rms > 0.05 ) {
                    context.fillStyle = "#30F07C";
                    context.save();
                    context.globalAlpha = 0.4;
                    context.fillRect( 0, vStep * 7, width, height );
                    if( rms > 0.15 ) {
                        context.restore();
                        context.globalAlpha = 0.5;
                        context.fillRect( 0, vStep * 6, width, height );
                        if( rms > 0.25 ) {
                            context.restore();
                            context.globalAlpha = 0.65;
                            context.fillRect( 0, vStep * 5, width, height );
                            if( rms > 0.35 ) {
                                context.restore();
                                context.globalAlpha = 0.85;
                                context.fillRect( 0, vStep * 4, width, height );
                                if( rms > 0.45 ) {
                                    context.restore();
                                    context.fillStyle = "#30E67C";
                                    context.fillRect( 0, vStep * 3, width, height );
                                    if( rms > 0.55 ) {
                                        context.fillStyle = "#FCEE21";
                                        context.fillRect( 0, vStep * 2, width, height );
                                        if( rms > 0.65 ) {
                                            context.fillStyle = "#F7931E";
                                            context.fillRect( 0, vStep * 1, width, height );
                                            if( rms > 0.85 ) {
                                                context.fillStyle = "#F15A24";
                                                context.fillRect( 0, vStep * 0, width, height );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            /**************************************************
             *           utility methods
             **************************************************/

            function getResponseIdentifier() {
                var rId = $container.attr('data-identifier');
                if ( rId === undefined ) {
                    rId = $container.attr('responseIdentifier');
                }
                return rId;
            }

            function callMethodIfDefined( caller, methodName ) {
                if ( typeof caller !== 'undefined' && caller.hasOwnProperty( methodName ) && typeof caller[ methodName ] === 'function' ) {
                    caller[ methodName ]();
                }
            }

            function isRecording() {
                return _state === 'record' || _state === 'permission';
            }

            function setConfigDefaults() {
                var defaults = {
                    attempts: 1,
                    recordingLength: 120,
                    allowReview: false,
                    codec:_codec,
                    recorderId: _id,
                    spxQuality: 9,
                    teiRepo: false,
                    useBlob: false,
                    recordingOptions: {
                        bufferSize: 2048,
                        numInputChannels: 1,
                        numOutputChannels: 1,
                        encoderSampleRate: 48000
                    },
                    options: {
                        micGain: 25,
                        oggPlayback: true
                    }
                };

                //if ( _canSetPlaybackOptions && config.hasOwnProperty('options') && Object.prototype.toString.call(config.options) === '[object Object]' ) {
                config.options = config.options || {};
                if ( _canSetPlaybackOptions ) {
                    $.each( config.options, function( key, value ) {
                        //console.log('config.options[',key,']:',value);
                        switch( key ) {
                            case 'quickPlayback':
                                _quickPlayback = value;
                                break;
                            case 'flashRecord':
                                _flashRecord = value;
                                break;
                            case 'flashPlayback':
                                _flashPlayback = value;
                                break;
                            case 'useFlashEncoding':
                                _useFlashEncoding = value;
                                break;
                             case 'progressiveEncode':
                                _progressiveEncode = value;
                                config.progressiveEncode = value;
                                break;
                            case 'codec':
                                _codec = value;
                                config.codec = value;
                                break;
                        }
                    });
                    // codec must be 'opus' for progressive encode
                    config.options.progressiveEncode = config.progressiveEncode = _progressiveEncode = _progressiveEncode && _codec === 'opus';
                }
                config = $.extend( true, {}, defaults, config );
            }

            function parseRecordingLength( recordingLength ) {
                var recordingTime = parseInt( recordingLength );
                if( isNaN( recordingTime ) ) {
                    recordingTime = MAX_RECORDING_TIME;
                }
                return Math.min( MAX_RECORDING_TIME, recordingTime ) * 1000;
            }

            function uniqueId() {
                var s = $container.attr('id');
                var l = 0;
                if ( typeof s !== 'string' && s.length <= 0 ) {
                    s = '';
                    l = 8;
                } else {
                    // l = 4;
                    // s += "_";
                }
                var i, c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                for ( i=0; i<l; i++ ) { s += c.charAt(Math.floor(Math.random() * (i === 0 ? c.length-10 : c.length) )); }
                return s;


            }

            function rms( data ) {
                var sum = 0;
                for ( var i = 0; i < data.length; i++ ) {
                    sum += data[ i ] * data[ i ];
                }
                return Math.sqrt( sum / data.length );
            }

            // TODO: update using _player
            function getRecordingDuration( useMaxTime ) {
                var duration = _elapsedTime / 1000;
                if ( useMaxTime ) {
                    duration = _times.totalRecordingTime / 1000;
                } else if ( _player && _player.getRecordingDuration() > 0 ) {
                    duration = _player.getRecordingDuration();
                }
                return duration;
            }

            function getAnimDurationOptionsArray() {
                return [ '-webkit-animation-duration', '-moz-animation-duration', '-o-animation-duration', 'animation-duration', '' ].slice(0);
            }

            function getTransDurationOptionsArray() {
                return [ '-webkit-transition-duration', '-moz-transition-duration', '-o-transition-duration', 'transition-duration', '' ].slice(0);
            }

            function doLog() {
                var args = ['---- AudioRecorder >'].concat( Array.prototype.slice.call(arguments) );
                console.log.apply( console, args);
            }

            /**********************************************************
             *          returned public API
             **********************************************************/

            return {
                initialize: init,
                getResponseData: getResponseData,
                setResponseData: setResponseData,
                isAnswered: isAnswered,
                finalize: finalize,
                onPlaybackStart: onPlaybackStart,
                onPlaybackStop: onPlaybackStop,
                onPlaybackEnd: onPlaybackEnd,
                stop: stop,
                setState: setState,
                getResponseAudioData: getResponseAudioData,
                getRecorder: getRecorder,
                getRecorderType: getRecorderType,
                setDebugValue: setDebugValue,
                showPlaybackError: showPlaybackError,
                setAudioKey: setAudioKey,
                getAudioFromKey: getAudioFromKey,
                animPlaybackMarker: animPlaybackMarker,
                confirmDelete: confirmDelete,
                WEBRTC: WEBRTC,
                FLASH: FLASH,
                CORDOVA: CORDOVA
            };
        }

        return Recorder;
});
define(
    'jquery.widget.recorder',[
        'recorder'
    ],
    function( Recorder ) {
        $.widget( 'pearson.recorder', {

            _createdTime: null,
            _startRecordingTime: null,
            _endRecordingTime: null,

            _create: function() {
                this._recorder = new Recorder( this.options, this.element );

                this.element.on( "record-start.VoiceRecorder", $.proxy( this._handleRecordingStart, this  ) );
                this.element.on( "record-stop.VoiceRecorder", $.proxy( this._handleRecordingStop, this ) );
                this.element.on( "not-supported.VoiceRecorder", $.proxy( this._handleNotSupported, this ) );
                this._recorder.initialize();

                this._createdTime = Date.now();
        	},

            getResponseData: function() {
                this._recorder.getResponseData();
            },

            deleteRecording: function() {
                this._recorder.confirmDelete();
            },

            setResponseData: function( response ) {
                this._recorder.setResponseData( response );
            },

            getAnswered: function(){
                return  this._recorder.isAnswered();
            },

            stop: function() {
                this._recorder.stop();
            },

            destroy: function() {
                // They may have already recorded, so only send post recording time if we have a stop time.
                if( this._stopRecordingTime ) {
                    var postTime = ( Date.now() - this._stopRecordingTime )/1000;
                    this._recordAnalytics( "PostRecordingTime", postTime );
                }
                // finalize/destroy recorder
                this.element.off('.VoiceRecorder');
                this._recorder.finalize();
                $.Widget.prototype.destroy.call( this );
            },

            _handleRecordingStart: function( e ) {
                this._startRecordingTime = Date.now();
                var timeToStart = ( this._startRecordingTime - this._createdTime )/1000;
                this._recordAnalytics( "PreRecordingTime", timeToStart );
            },

            _handleRecordingStop: function( e ) {
                this._stopRecordingTime = Date.now();
                var recordingTime = ( this._stopRecordingTime - this._startRecordingTime )/1000;
                this._recordAnalytics( "RecordingTime", recordingTime );
            },

            _handleNotSupported: function( e ) {
                this._recordAnalytics( "NotSupported", "" );
            },

            _recordAnalytics: function( action, value ) {
                if( window.ga ) {
                    // Google Analytics tracking:
                    // ga( 'send' 'event', category, action, opt_label, opt_value );
                    // opt_value must be an integer.
                    value = Math.round( value );
                    ga( 'send', 'event', 'VoiceRecorder', action, '', value );
                    console.log( "ga analytics: action = " + action + ", value = " + value );
                }
            }
        });
    }
);
// TODO: with grunt build this is redundant.
// require( 'jquery.widget.recorder' );

return require('jquery.widget.recorder'); }));
//# sourceMappingURL=jquery.widget.recorder.min.js.map